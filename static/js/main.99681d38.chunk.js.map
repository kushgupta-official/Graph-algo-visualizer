{"version":3,"sources":["graphAlgoVisualizer/node/node.jsx","graphAlgoVisualizer/navbar.jsx","algorithms/dijkstra.js","algorithms/aStar.js","algorithms/bfs.js","algorithms/dfs.js","graphAlgoVisualizer/graphAlgoVisualizer.jsx","minimumSpanningTree/canvas.jsx","minimumSpanningTree/minimumSpanningTree.js","Header.js","App.js","serviceWorker.js","index.js"],"names":["Node","state","getClassName","str","props","isStart","isEnd","isWall","weight","visitedNode","pathNode","this","row","column","onMouseDown","onMouseUp","onMouseEnter","onMouseLeave","className","id","Component","Checkbox","type","classNavbar","currentAlgo","addWeights","forDijkstra","setState","handleDescription","forAstar","forBFS","forDFS","visualize","handleDijkstra","handleAstar","handleBFS","handleDFS","handleCheckboxChange","console","log","handleClearAlgorithm","handleClearGrid","timeComplexity","pathLength","pathCost","Navbar","bg","variant","expand","sticky","Brand","Toggle","aria-controls","Collapse","Nav","NavDropdown","title","Item","onClick","Button","checked","onChange","dijkstra","grid","startNode","endNode","visitedNodeInOrder","distance","unvisitedNodes","nodes","columns","push","getAllNodes","length","sortNodesByDistance","nearestNode","shift","isVisited","Infinity","updateUnvisitedNeighbours","sort","nodeA","nodeB","node","unvisitedNeighbours","getUnvisitedNeighbours","ite","previousNode","getShortestPathDijkstra","shortestPath","previous","reverse","getWeightOfShortestPathDijkstra","weightOfPath","aStar","visitedNodesInOrder","Math","abs","toReturn","rows","sortNodesByValueF","nextNode","currentNode","targetNode","distanceBetweenCurrentAndTarget","g_currentNode","g_ite","h_ite","getShortestPathAstar","getWeightOfShortestPathAstar","bfs","queue","currNode","pushNeighboursOfCurrentNode","neighboursOfCurrentNode","getNeighboursOfCurrentNode","getPathBFS","path","getWeightOfShortestPathBFS","dfs","stack","pop","pushNeighboursOfNode","neighboursOfNode","getNeighboursOfNode","getPathDFS","getWeightOfPathDFS","startNode_Row","startNode_Col","endNode_Row","endNode_Col","GraphAlgoVisualizer","isMousePressed","isMovingStart","isMovingEnd","processActive","description","getNewGridWithWallToggled","newGrid","slice","newNode","getNewGridWithWeights","changeInValue","handleMouseDown","handleMouseEnter","handleMouseUp","handleMouseLeave","animateAlgo","document","getElementById","disabled","i","j","setTimeout","newGridNode","visualizeDijkstra","clearAlgo","shortestPathCost","visualizeAstar","visualizeBFS","visualizeDFS","undoAlgoAndWalls","getDescription","algo","currentRow","map","rowIdx","key","nodeIdx","role","aria-label","href","target","rel","Canvas","coord","ctx","canvas","getContext","draw","visited","unvisited","unvisited1","first","splice","minEdge","parent","currentVertex","calWeight","drawPrims","x1","y1","x2","y2","x","pow","y","sqrt","outline","width","window","innerWidth","height","innerHeight","newCanvas","e","xypair","clientX","clientY","newCoord","prims","onContextMenu","preventDefault","coordX","coordY","ref","React","MinimumSpanningTree","ChildElement","createRef","strokeRect","rect","getBoundingClientRect","clearRect","fillStyle","beginPath","arc","left","top","PI","fill","source","destination","strokeStyle","moveTo","lineTo","stroke","Header","justify","defaultActiveKey","to","Link","eventKey","App","exact","element","Boolean","location","hostname","match","ReactGA","initialize","pageview","pathname","search","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"mUA6DeA,G,kNAzDbC,MAAQ,G,EACRC,aAAe,WACb,IAAIC,EAAM,OAsBV,OArB2B,IAAvB,EAAKC,MAAMC,QACbF,GAAY,cACkB,IAArB,EAAKC,MAAME,MACpBH,GAAY,YACmB,IAAtB,EAAKC,MAAMG,OACpBJ,GAAY,aACH,EAAKC,MAAMI,OAAS,IAC7BL,GAAY,oBAEiB,IAA3B,EAAKC,MAAMK,cACbN,GAAY,kBAEc,IAAxB,EAAKC,MAAMM,WACbP,GAAY,uBAEc,IAAxB,EAAKC,MAAMM,UAAqB,EAAKN,MAAMI,OAAS,EACtDL,EAAM,4BAE4B,IAA3B,EAAKC,MAAMK,aAAwB,EAAKL,MAAMI,OAAS,IAC9DL,EAAM,+BAEDA,G,uDAGC,IAAD,EAeHQ,KAAKP,MAbPQ,EAFK,EAELA,IACAC,EAHK,EAGLA,OAQAC,EAXK,EAWLA,YACAC,EAZK,EAYLA,UACAC,EAbK,EAaLA,aACAC,EAdK,EAcLA,aAGF,OACE,yBACEC,UAAWP,KAAKT,eAChBiB,GAAE,eAAUP,EAAV,YAAiBC,GACnBC,YAAa,kBAAMA,EAAYF,EAAKC,IACpCG,aAAc,kBAAMA,EAAaJ,EAAKC,IACtCE,UAAW,kBAAMA,EAAUH,EAAKC,IAChCI,aAAc,kBAAMA,EAAaL,EAAIC,U,GApD1BO,c,gCCIbC,G,MAAW,SAACjB,GAAD,OAAW,yCAAOkB,KAAK,YAAelB,MAiHxCmB,E,4MA9GbtB,MAAQ,CACNuB,YAAa,mBACbC,WAAY,S,EAEdC,YAAc,WACZ,EAAKC,SAAS,CAAEH,YAAa,aAC7B,EAAKpB,MAAMwB,kBAAkB,a,EAE/BC,SAAW,WACT,EAAKF,SAAS,CAAEH,YAAa,cAC7B,EAAKpB,MAAMwB,kBAAkB,U,EAE/BE,OAAS,WACP,EAAKH,SAAS,CAAEH,YAAa,yBAC7B,EAAKpB,MAAMwB,kBAAkB,Q,EAE/BG,OAAS,WACP,EAAKJ,SAAS,CAAEH,YAAa,uBAC7B,EAAKpB,MAAMwB,kBAAkB,Q,EAE/BI,UAAY,WACqB,aAA3B,EAAK/B,MAAMuB,YACb,EAAKpB,MAAM6B,iBACyB,cAA3B,EAAKhC,MAAMuB,YACpB,EAAKpB,MAAM8B,cACyB,yBAA3B,EAAKjC,MAAMuB,YACpB,EAAKpB,MAAM+B,YACyB,uBAA3B,EAAKlC,MAAMuB,aACpB,EAAKpB,MAAMgC,a,EAGfC,qBAAuB,WACrBC,QAAQC,IAAI,EAAKtC,MAAMwB,YACvB,EAAKE,SAAS,CAAEF,YAAa,EAAKxB,MAAMwB,c,uDAGhC,IAAD,EASHd,KAAKP,MAPPoC,EAFK,EAELA,qBACAC,EAHK,EAGLA,gBACAhB,EAJK,EAILA,WACAY,EALK,EAKLA,qBACAK,EANK,EAMLA,eACAC,EAPK,EAOLA,WACAC,EARK,EAQLA,SAEF,OACE,kBAACC,EAAA,EAAD,CAAQC,GAAG,OAAOC,QAAQ,OAAOC,OAAO,KAAKC,OAAO,OAClD,kBAACJ,EAAA,EAAOK,MAAR,CAAchC,UAAU,QAAxB,2BACA,kBAAC2B,EAAA,EAAOM,OAAR,CAAeC,gBAAc,qBAC7B,kBAACP,EAAA,EAAOQ,SAAR,CAAiBlC,GAAG,oBAClB,kBAACmC,EAAA,EAAD,CAAKpC,UAAU,WAGb,kBAACqC,EAAA,EAAD,CAAaC,MAAO7C,KAAKV,MAAMuB,YAAaL,GAAG,sBAC7C,kBAACoC,EAAA,EAAYE,KAAb,CAAkBC,QAAS/C,KAAKe,aAAhC,YAGA,kBAAC6B,EAAA,EAAYE,KAAb,CAAkBC,QAAS/C,KAAKkB,UAAhC,aAGA,kBAAC0B,EAAA,EAAYE,KAAb,CAAkBC,QAAS/C,KAAKmB,QAAhC,wBAGA,kBAACyB,EAAA,EAAYE,KAAb,CAAkBC,QAAS/C,KAAKoB,QAAhC,uBAQF,kBAAC4B,EAAA,EAAD,CACEZ,QAAQ,UACR7B,UAAU,OACVwC,QAAS/C,KAAKqB,UACdb,GAAG,aAJL,cAQA,kBAACwC,EAAA,EAAD,CACEZ,QAAQ,OACR7B,UAAU,OACVC,GAAG,YACHuC,QAASlB,GAJX,mBAQA,kBAACmB,EAAA,EAAD,CACEZ,QAAQ,OACR7B,UAAU,OACVwC,QAASjB,EACTtB,GAAG,aAJL,cAQA,2BAAOD,UAAU,QACf,kBAAC,EAAD,CAAU0C,QAASnC,EAAYoC,SAAUxB,IACzC,0BAAMnB,UAAU,YAAhB,sBAEF,2BAAOA,UAAU,iBAAjB,iBAAgDyB,GAChD,2BAAOzB,UAAU,iBAAjB,eAA8C0B,GAC9C,2BAAO1B,UAAU,iBAAjB,qBAAoDwB,U,GAvGtCtB,a,OCTnB,SAAS0C,EAASC,EAAMC,EAAWC,GACxC,IAAMC,EAAqB,GAC3BF,EAAUG,SAAW,EAGrB,IAFA,IAAMC,EAuDR,SAAqBL,GACnB,IADyB,EACrBM,EAAQ,GADa,cAETN,GAFS,IAEzB,2BAAsB,CAAC,IAAD,EAAbnD,EAAa,sBACAA,GADA,IACpB,2BAAyB,CAAC,IAAjB0D,EAAgB,QACvBD,EAAME,KAAKD,IAFO,gCAFG,8BAOzB,OAAOD,EA9DgBG,CAAYT,GAE1BK,EAAeK,QAAQ,CAC9BC,EAAoBN,GACpB,IAAMO,EAAcP,EAAeQ,QAEnC,GADAD,EAAYE,WAAY,EACpBF,EAAYR,WAAaW,IAC3B,OAAOZ,EAET,IAA2B,IAAvBS,EAAYpE,OAAhB,CAKA,GADA2D,EAAmBK,KAAKI,GACpBA,IAAgBV,EAClB,OAAOC,EAETa,EAA0BJ,EAAaZ,KAK3C,SAASW,EAAoBN,GAC3BA,EAAeY,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAMd,SAAWe,EAAMf,YAG/D,SAASY,EAA0BI,EAAMpB,GACvC,IAD6C,EACvCqB,EAUR,SAAgCD,EAAMpB,GACpC,IAAMqB,EAAsB,GACpBxE,EAAgBuE,EAAhBvE,IAAKC,EAAWsE,EAAXtE,OACTD,EAAM,GAAK,IAAyC,IAApCmD,EAAKnD,EAAM,GAAGC,GAAQgE,WACxCO,EAAoBb,KAAKR,EAAKnD,EAAM,GAAGC,IAErCD,EAAM,EAAImD,EAAKU,SAA8C,IAApCV,EAAKnD,EAAM,GAAGC,GAAQgE,WACjDO,EAAoBb,KAAKR,EAAKnD,EAAM,GAAGC,IAErCA,EAAS,GAAK,IAAyC,IAApCkD,EAAKnD,GAAKC,EAAS,GAAGgE,WAC3CO,EAAoBb,KAAKR,EAAKnD,GAAKC,EAAS,IAE1CA,EAAS,EAAIkD,EAAK,GAAGU,SAA8C,IAApCV,EAAKnD,GAAKC,EAAS,GAAGgE,WACvDO,EAAoBb,KAAKR,EAAKnD,GAAKC,EAAS,IAE9C,OAAOuE,EAzBqBC,CAAuBF,EAAMpB,GADZ,cAE7BqB,GAF6B,IAE7C,2BAAqC,CAAC,IAA7BE,EAA4B,QAC/BA,EAAInB,SAAWgB,EAAKhB,SAAWmB,EAAI9E,SACrC8E,EAAInB,SAAWgB,EAAKhB,SAAWmB,EAAI9E,OAAS,EAC5C8E,EAAIC,aAAeJ,IALsB,8BAQ7C,OAAOC,EA+BF,SAASI,EAAwBzB,EAAMC,EAAWC,GACvD,IAAMwB,EAAe,GACjBC,EAAWzB,EAAQsB,aACvB,GAAiB,OAAbG,EACF,OAAOD,EAET,KAAOC,IAAa1B,GAClByB,EAAalB,KAAKmB,GAClBA,EAAWA,EAASH,aAGtB,OADAE,EAAaE,UACNF,EAGF,SAASG,EAAgC7B,EAAM0B,GACpD,IADkE,EAC9DI,EAAe,EAD+C,cAElDJ,GAFkD,IAElE,2BAA8B,CAAC,IAAtBH,EAAqB,QACT,IAAfA,EAAI9E,OACNqF,GAA8B,EAE9BA,EAAeA,EAAeP,EAAI9E,OAAS,GANmB,8BASlE,OAAOqF,ECzFF,SAASC,EAAM/B,EAAMC,EAAWC,GACrC,IAAM8B,EAAsB,GAC5B/B,EAAUG,SACR6B,KAAKC,IAAIjC,EAAUpD,IAAMqD,EAAQrD,KACjCoF,KAAKC,IAAIjC,EAAUnD,OAASoD,EAAQpD,QAGtC,IADA,IAAMuD,EAuBR,SAAqBL,GACnB,IADyB,EACnBmC,EAAW,GADQ,cAERnC,GAFQ,IAEzB,2BAAuB,CAAC,IAAD,EAAdoC,EAAc,sBACDA,GADC,IACrB,2BAA0B,CAAC,IAAlB7B,EAAiB,QACxB4B,EAAS3B,KAAKD,IAFK,gCAFE,8BAOzB,OAAO4B,EA9BgB1B,CAAYT,GAC1BK,EAAeK,QAAQ,CAC9B2B,EAAkBhC,GAClB,IAAMiC,EAAWjC,EAAeQ,QAChC,GAAIyB,EAASlC,WAAaW,IACxB,OAAOiB,EAET,IAAIM,EAAS9F,OAAb,CAKA,GAFA8F,EAASxB,WAAY,EACrBkB,EAAoBxB,KAAK8B,GACrBA,IAAapC,EACf,OAAO8B,EAEThB,EAA0BsB,EAAUpC,EAASF,KAIjD,SAASqC,EAAkBhC,GACzBA,EAAeY,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAMd,SAAWe,EAAMf,YAa/D,SAASY,EAA0BuB,EAAaC,EAAYxC,GAC1D,IADgE,EAC1DqB,EA4CR,SAAgCkB,EAAavC,GAC3C,IAAMqB,EAAsB,GACpBxE,EAAgB0F,EAAhB1F,IAAKC,EAAWyF,EAAXzF,OACTD,EAAM,GAAK,IAAyC,IAApCmD,EAAKnD,EAAM,GAAGC,GAAQgE,WACxCO,EAAoBb,KAAKR,EAAKnD,EAAM,GAAGC,IAErCD,EAAM,EAAImD,EAAKU,SAA8C,IAApCV,EAAKnD,EAAM,GAAGC,GAAQgE,WACjDO,EAAoBb,KAAKR,EAAKnD,EAAM,GAAGC,IAErCA,EAAS,GAAK,IAAyC,IAApCkD,EAAKnD,GAAKC,EAAS,GAAGgE,WAC3CO,EAAoBb,KAAKR,EAAKnD,GAAKC,EAAS,IAE1CA,EAAS,EAAIkD,EAAK,GAAGU,SAA8C,IAApCV,EAAKnD,GAAKC,EAAS,GAAGgE,WACvDO,EAAoBb,KAAKR,EAAKnD,GAAKC,EAAS,IAE9C,OAAOuE,EA3DqBC,CAAuBiB,EAAavC,GAC1DyC,EACJR,KAAKC,IAAIK,EAAY1F,IAAM2F,EAAW3F,KACtCoF,KAAKC,IAAIK,EAAYzF,OAAS0F,EAAW1F,QACrC4F,EAAgBH,EAAYnC,SAAWqC,EALmB,cAMhDpB,GANgD,IAMhE,2BAAqC,CAAC,IAA7BE,EAA4B,QAC/BoB,EAAQD,EAAgBnB,EAAI9E,OAAS,EACrCmG,EACFX,KAAKC,IAAIX,EAAI1E,IAAM2F,EAAW3F,KAC9BoF,KAAKC,IAAIX,EAAIzE,OAAS0F,EAAW1F,QAC/ByE,EAAInB,SAAWuC,EAAQC,IACzBrB,EAAInB,SAAWuC,EAAQC,EACvBrB,EAAIC,aAAee,IAbyC,8BAgBhE,OAAOlB,EA+CF,SAASwB,EAAqB7C,EAAMC,EAAWC,GACpD,IAAMwB,EAAe,GACjBC,EAAWzB,EAAQsB,aACvB,GAAiB,OAAbG,EACF,OAAOD,EAET,KAAOC,IAAa1B,GAClByB,EAAalB,KAAKmB,GAClBA,EAAWA,EAASH,aAGtB,OADAE,EAAaE,UACNF,EAGF,SAASoB,EAA6B9C,EAAM0B,GACjD,IAD+D,EAC3DI,EAAe,EAD4C,cAE/CJ,GAF+C,IAE/D,2BAA8B,CAAC,IAAtBH,EAAqB,QACT,IAAfA,EAAI9E,OACNqF,GAA8B,EAE9BA,EAAeA,EAAeP,EAAI9E,OAAS,GANgB,8BAS/D,OAAOqF,EC/HF,SAASiB,EAAI/C,EAAMC,EAAWC,GACnC,IAAM8B,EAAsB,GAC5B/B,EAAUa,WAAY,EAEtB,IAAMkC,EAAQ,GAEd,IADAA,EAAMxC,KAAKP,GACF+C,EAAMtC,QAAQ,CACrB,IAAMuC,EAAWD,EAAMnC,QACvB,GAAIoC,IAAa/C,EACf,OAAO8B,EAELiB,EAASzG,SAGbwF,EAAoBxB,KAAKyC,GACzBC,EAA4BlD,EAAMgD,EAAOC,IAE3C,OAAOjB,EAGT,SAASkB,EAA4BlD,EAAMgD,EAAOC,GAChD,IAD0D,EACpDE,EAQR,SAAoCnD,EAAMiD,GACxC,IAAMd,EAAW,GACXtF,EAAMoG,EAASpG,IACfC,EAASmG,EAASnG,OAEpBD,EAAM,GAAK,IAAMmD,EAAKnD,EAAM,GAAGC,GAAQgE,WACzCqB,EAAS3B,KAAKR,EAAKnD,EAAM,GAAGC,IAE1BA,EAAS,GAAK,IAAMkD,EAAKnD,GAAKC,EAAS,GAAGgE,WAC5CqB,EAAS3B,KAAKR,EAAKnD,GAAKC,EAAS,IAE/BD,EAAM,EAAImD,EAAKU,SAAWV,EAAKnD,EAAM,GAAGC,GAAQgE,WAClDqB,EAAS3B,KAAKR,EAAKnD,EAAM,GAAGC,IAE1BA,EAAS,EAAIkD,EAAK,GAAGU,SAAWV,EAAKnD,GAAKC,EAAS,GAAGgE,WACxDqB,EAAS3B,KAAKR,EAAKnD,GAAKC,EAAS,IAEnC,OAAOqF,EAzByBiB,CAA2BpD,EAAMiD,GADP,cAEzCE,GAFyC,IAE1D,2BAA0C,CAAC,IAAlC/B,EAAiC,QACxCA,EAAKN,WAAY,EACjBM,EAAKI,aAAeyB,EACpBD,EAAMxC,KAAKY,IAL6C,+BAuCrD,SAASiC,EAAWrD,EAAMC,EAAWC,GAC1C,IAAMoD,EAAO,GACT3B,EAAWzB,EAAQsB,aACvB,GAAiB,OAAbG,EACF,OAAO2B,EAET,KAAO3B,IAAa1B,GAClBqD,EAAK9C,KAAKmB,GACVA,EAAWA,EAASH,aAGtB,OADA8B,EAAK1B,UACE0B,EAGF,SAASC,EAA2BvD,EAAMsD,GAC/C,IADqD,EACjDxB,EAAe,EADkC,cAErCwB,GAFqC,IAErD,2BAAsB,CAAC,IAAd/B,EAAa,QACD,IAAfA,EAAI9E,OACNqF,GAA8B,EAE9BA,EAAeA,EAAeP,EAAI9E,OAAS,GANM,8BASrD,OAAOqF,EClFF,SAAS0B,EAAIxD,EAAMC,EAAWC,GACnC,IAAM8B,EAAsB,GACtByB,EAAQ,GAGd,IAFAxD,EAAUa,WAAY,EACtB2C,EAAMjD,KAAKP,GACFwD,EAAM/C,QAAQ,CACrB,IAAM4B,EAAWmB,EAAMC,MACvB,IAAwB,IAApBpB,EAAS9F,OAAb,CAIA,GADAwF,EAAoBxB,KAAK8B,GACrBA,IAAapC,EACf,OAAO8B,EAET2B,EAAqB3D,EAAMyD,EAAOnB,IAEpC,OAAON,EAGT,SAAS2B,EAAqB3D,EAAMyD,EAAOrC,GACzC,IAD+C,EACzCwC,EAUR,SAA6B5D,EAAMoB,GACjC,IAAMC,EAAsB,GACtBxE,EAAMuE,EAAKvE,IACXC,EAASsE,EAAKtE,OAEhBD,EAAM,GAAK,IAAyC,IAApCmD,EAAKnD,EAAM,GAAGC,GAAQgE,WACxCO,EAAoBb,KAAKR,EAAKnD,EAAM,GAAGC,IAErCA,EAAS,GAAK,IAAyC,IAApCkD,EAAKnD,GAAKC,EAAS,GAAGgE,WAC3CO,EAAoBb,KAAKR,EAAKnD,GAAKC,EAAS,IAE1CD,EAAM,EAAImD,EAAKU,SAA8C,IAApCV,EAAKnD,EAAM,GAAGC,GAAQgE,WACjDO,EAAoBb,KAAKR,EAAKnD,EAAM,GAAGC,IAGvCA,EAAS,EAAIkD,EAAK,GAAGU,SACe,IAApCV,EAAKnD,GAAKC,EAAS,GAAGgE,WAEtBO,EAAoBb,KAAKR,EAAKnD,GAAKC,EAAS,IAG9C,OAAOuE,EA/BkBwC,CAAoB7D,EAAMoB,GADJ,cAE/BwC,GAF+B,IAE/C,2BAAkC,CAAC,IAA1BrC,EAAyB,QACT,OAAnBA,EAAIC,eACND,EAAIC,aAAeJ,GAErBG,EAAIT,WAAY,EAChB2C,EAAMjD,KAAKe,IAPkC,+BAmC1C,SAASuC,EAAW9D,EAAMC,EAAWC,GAC1C,IAAMoD,EAAO,GACT3B,EAAWzB,EAAQsB,aACvB,GAAiB,OAAbG,EACF,OAAO2B,EAET,KAAO3B,IAAa1B,GAClBqD,EAAK9C,KAAKmB,GACVA,EAAWA,EAASH,aAGtB,OADA8B,EAAK1B,UACE0B,EAGF,SAASS,EAAmB/D,EAAMsD,GACvC,IAD6C,EACzCxB,EAAe,EAD0B,cAE7BwB,GAF6B,IAE7C,2BAAsB,CAAC,IAAd/B,EAAa,QACD,IAAfA,EAAI9E,OACNqF,GAA8B,EAE9BA,EAAeA,EAAeP,EAAI9E,OAAS,GANF,8BAS7C,OAAOqF,ECvDT,IAEIkC,EAAgB,EAChBC,EAAgB,GAChBC,EAAc,GACdC,EAAc,GAmjBHC,E,4MA/iBblI,MAAQ,CACN8D,KAAM,GACNqE,gBAAgB,EAChB1F,eAAgB,EAChBE,SAAU,EACVD,WAAY,EACZ0F,eAAe,EACfC,aAAa,EACb7G,YAAY,EACZ8G,eAAe,EACfC,YAAa,oK,EA4BfC,0BAA4B,SAAC7H,EAAKC,GAChC,IAAM6H,EAAU,EAAKzI,MAAM8D,KAAK4E,QAC1BxD,EAAOuD,EAAQ9H,GAAKC,GACpB+H,EAAO,2BACRzD,GADQ,IAEX5E,QAAS4E,EAAK5E,OACdC,OAAQ,IAGV,OADAkI,EAAQ9H,GAAKC,GAAU+H,EAChBF,G,EAGTG,sBAAwB,SAACjI,EAAKC,GAC5B,IAAM6H,EAAU,EAAKzI,MAAM8D,KAAK4E,QAC1BxD,EAAOuD,EAAQ9H,GAAKC,GACtBiI,EAAgB,EAElBA,EADkB,IAAhB3D,EAAK3E,OAzDO,OA8DhB,IAAMoI,EAAO,2BACRzD,GADQ,IAEX5E,QAAQ,EACRC,OAAQ2E,EAAK3E,OAASsI,IAGxB,OADAJ,EAAQ9H,GAAKC,GAAU+H,EAChBF,G,EAGTK,gBAAkB,SAACnI,EAAKC,GAWpB,IAAI6H,EAVN,IAAiC,IAA7B,EAAKzI,MAAMsI,cAGf,GAEK3H,IAAQmH,GAAiBlH,IAAWmH,GACpCpH,IAAQqH,GAAepH,IAAWqH,GAgBrC,GADA,EAAKvG,SAAS,CAAEyG,gBAAgB,IAC5BxH,IAAQmH,GAAiBlH,IAAWmH,EAAe,CACrD,IAAMU,EAAU,EAAKzI,MAAM8D,KAAK4E,QAC1BxD,EAAOuD,EAAQ9H,GAAKC,GACpB+H,EAAO,2BACRzD,GADQ,IAEX9E,SAAS,IAEXqI,EAAQ9H,GAAKC,GAAU+H,EACvB,EAAKjH,SAAS,CAAEoC,KAAM2E,EAASL,eAAe,SACzC,GAAIzH,IAAQqH,GAAepH,IAAWqH,EAAa,CACxD,IAAMQ,EAAU,EAAKzI,MAAM8D,KAAK4E,QAC1BxD,EAAOuD,EAAQ9H,GAAKC,GACpB+H,EAAO,2BACRzD,GADQ,IAEX7E,OAAO,IAEToI,EAAQ9H,GAAKC,GAAU+H,EACvB,EAAKjH,SAAS,CAAEoC,KAAM2E,EAASJ,aAAa,UAzB5CI,EAHG,EAAKzI,MAAMwB,WAGJ,EAAKoH,sBAAsBjI,EAAKC,GAFhC,EAAK4H,0BAA0B7H,EAAKC,GAIhD,EAAKc,SAAS,CAAEoC,KAAM2E,EAASN,gBAAgB,K,EA4BnDY,iBAAmB,SAACpI,EAAKC,GAEvB,GAAK,EAAKZ,MAAMmI,gBAAmB,EAAKnI,MAAMsI,cAA9C,CAsBA,GAAI,EAAKtI,MAAMoI,cAAc,CAC3B,IAAMK,EAAQ,EAAKzI,MAAM8D,KACzB2E,EAAQX,GAAeC,GAAe3H,SAAQ,EAC9CqI,EAAQ9H,GAAKC,GAAQR,SAAQ,EAC7B0H,EAAcnH,EACdoH,EAAcnH,EACd,EAAKc,SAAS,CAACoC,KAAK2E,SAEjB,GAAI,EAAKzI,MAAMqI,YAAY,CAC9B,IAAMI,EAAQ,EAAKzI,MAAM8D,KACzB2E,EAAQT,GAAaC,GAAa5H,OAAM,EACxCoI,EAAQ9H,GAAKC,GAAQP,OAAM,EAC3B2H,EAAYrH,EACZsH,EAAYrH,EACZ,EAAKc,SAAS,CAACoC,KAAK2E,IAUpB,IAAIA,EARN,GACE,EAAKzI,MAAMmI,kBAERxH,IAAQmH,GAAiBlH,IAAWmH,GACpCpH,IAAQqH,GAAepH,IAAWqH,GAQnCQ,EAHG,EAAKzI,MAAMwB,WAGJ,EAAKoH,sBAAsBjI,EAAKC,GAFhC,EAAK4H,0BAA0B7H,EAAKC,GAIhD,EAAKc,SAAS,CAAEoC,KAAM2E,QApDxB,CAQI,IAAIA,EALD9H,IAAQmH,GAAiBlH,IAAWmH,GACpCpH,IAAQqH,GAAepH,IAAWqH,IAQnCQ,EAHG,EAAKzI,MAAMwB,WAGJ,EAAKoH,sBAAsBjI,EAAKC,GAFhC,EAAK4H,0BAA0B7H,EAAKC,GAIhD,EAAKc,SAAS,CAAEoC,KAAM2E,O,EA4C5BO,cAAgB,SAACrI,EAAKC,GACpB,IAAiC,IAA7B,EAAKZ,MAAMsI,cAOf,GAHA,EAAK5G,SAAS,CAAEyG,gBAAgB,KAGC,IAA7B,EAAKnI,MAAMoI,cAAwB,CACrC,IAAMK,EAAU,EAAKzI,MAAM8D,KAAK4E,QAC1BxD,EAAOuD,EAAQ9H,GAAKC,GACpB+H,EAAO,2BACRzD,GADQ,IAEX5E,QAAQ,EACRF,SAAS,IAEXqI,EAAQ9H,GAAKC,GAAU+H,EACvB,EAAKjH,SAAS,CAAEoC,KAAM2E,EAASL,eAAe,IAC9CN,EAAgBnH,EAChBoH,EAAgBnH,OACX,IAA+B,IAA3B,EAAKZ,MAAMqI,YAAsB,CAC1C,IAAMI,EAAU,EAAKzI,MAAM8D,KAAK4E,QAC1BxD,EAAOuD,EAAQ9H,GAAKC,GACpB+H,EAAO,2BACRzD,GADQ,IAEX5E,QAAQ,EACRD,OAAO,IAEToI,EAAQ9H,GAAKC,GAAU+H,EACvB,EAAKjH,SAAS,CAAEoC,KAAM2E,EAASJ,aAAa,IAC5CL,EAAcrH,EACdsH,EAAcrH,I,EAIlBqI,iBAAmB,SAACtI,EAAKC,GASnB,IAAI6H,EARH,EAAKzI,MAAMmI,gBAAmB,EAAKnI,MAAMsI,gBAGvC3H,IAAQmH,GAAiBlH,IAAWmH,GACpCpH,IAAQqH,GAAepH,IAAWqH,IAQnCQ,EAHG,EAAKzI,MAAMwB,WAGJ,EAAKoH,sBAAsBjI,EAAKC,GAFhC,EAAK4H,0BAA0B7H,EAAKC,GAIhD,EAAKc,SAAS,CAAEoC,KAAM2E,O,EAQ5BS,YAAc,SAACpD,EAAqBN,GAClC,EAAK9D,SAAS,CAAE4G,eAAe,IAC/Ba,SAASC,eAAe,aAAaC,UAAW,EAChDF,SAASC,eAAe,aAAaC,UAAW,EAChDF,SAASC,eAAe,aAAaC,UAAW,EAEhD,IADA,IAAMZ,EAAU,EAAKzI,MAAM8D,KAAK4E,QALmB,WAM1CY,GACP,GAAIA,IAAMxD,EAAoBtB,OAAS,EAAG,CACxC,IADyC,IAAD,WAC/B+E,GACPC,YAAW,WACTA,YAAW,WACT,IAAMtE,EAAOM,EAAa+D,GAIpBE,EAAchB,EAAQvD,EAAKvE,KAAKuE,EAAKtE,QACrC+H,EAAO,2BACRc,GADQ,IAEXhJ,UAAU,IAEZgI,EAAQvD,EAAKvE,KAAKuE,EAAKtE,QAAU+H,EAId,gCADjBQ,SAASC,eAAT,eAAgClE,EAAKvE,IAArC,YAA4CuE,EAAKtE,SAC9CK,UAEHkI,SAASC,eAAT,eACUlE,EAAKvE,IADf,YACsBuE,EAAKtE,SACzBK,UAAY,2BAEdkI,SAASC,eAAT,eACUlE,EAAKvE,IADf,YACsBuE,EAAKtE,SACzBK,UAAY,2BAEf,GAAKsI,KACP,GAAKD,IA3BDC,EAAI,EAAGA,EAAI/D,EAAahB,OAAQ+E,IAAM,EAAtCA,GAuCT,OATAC,YAAW,WACTA,YAAW,WACT,EAAK9H,SAAS,CAAE4G,eAAe,IAC/Ba,SAASC,eAAe,aAAaC,UAAW,EAChDF,SAASC,eAAe,aAAaC,UAAW,EAChDF,SAASC,eAAe,aAAaC,UAAW,EAChD,EAAK3H,SAAS,CAAEoC,KAAM2E,MACrB,GAAKjD,EAAahB,UACpB,GAAKsB,EAAoBtB,QACtB,CAAN,UAEFgF,YAAW,WACT,IAAMtE,EAAOY,EAAoBwD,GAErBG,EAAchB,EAAQvD,EAAKvE,KAAKuE,EAAKtE,QACrC+H,EAAO,2BACRc,GADQ,IAEXjJ,aAAa,IAEfiI,EAAQvD,EAAKvE,KAAKuE,EAAKtE,QAAU+H,EAIpB,wBADjBQ,SAASC,eAAT,eAAgClE,EAAKvE,IAArC,YAA4CuE,EAAKtE,SAC9CK,UAEHkI,SAASC,eAAT,eAAgClE,EAAKvE,IAArC,YAA4CuE,EAAKtE,SAAUK,UACzD,8BAEFkI,SAASC,eAAT,eAAgClE,EAAKvE,IAArC,YAA4CuE,EAAKtE,SAAUK,UACzD,sBAEH,GAAKqI,IA/DDA,EAAI,EAAGA,EAAIxD,EAAoBtB,OAAQ8E,IAAK,CAAC,IAAD,IAA5CA,GAA4C,oC,EAmEvDI,kBAAoB,WAGlB,EAAKC,YAHmB,IAIhB7F,EAAS,EAAK9D,MAAd8D,KACFC,EAAYD,EAAKgE,GAAeC,GAChC/D,EAAUF,EAAKkE,GAAaC,GAC5BnC,EAAsBjC,EAASC,EAAMC,EAAWC,GAEhDwB,EAAeD,EAAwBzB,EAAMC,EAAWC,GAExD4F,EAAmBjE,EACvB7B,EACA0B,GAEF,EAAK0D,YAAYpD,EAAqBN,GACtC,EAAK9D,SAAS,CACZe,eAAgBqD,EAAoBtB,OACpC9B,WAAY8C,EAAahB,OACzB7B,SAAUiH,K,EAOdC,eAAiB,WACf,EAAKF,YADgB,IAEb7F,EAAS,EAAK9D,MAAd8D,KACFC,EAAYD,EAAKgE,GAAeC,GAChC/D,EAAUF,EAAKkE,GAAaC,GAC5BnC,EAAsBD,EAAM/B,EAAMC,EAAWC,GAE7CwB,EAAemB,EAAqB7C,EAAMC,EAAWC,GAErD4F,EAAmBhD,EAA6B9C,EAAM0B,GAC5D,EAAK0D,YAAYpD,EAAqBN,GACtC,EAAK9D,SAAS,CACZe,eAAgBqD,EAAoBtB,OACpC9B,WAAY8C,EAAahB,OACzB7B,SAAUiH,K,EAMdE,aAAe,WACb,EAAKH,YADc,IAEX7F,EAAS,EAAK9D,MAAd8D,KACFC,EAAYD,EAAKgE,GAAeC,GAChC/D,EAAUF,EAAKkE,GAAaC,GAC5BnC,EAAsBe,EAAI/C,EAAMC,EAAWC,GAE3CoD,EAAOD,EAAWrD,EAAMC,EAAWC,GAEzC,EAAKkF,YAAYpD,EAAqBsB,GACtC,IAAMzE,EAAW0E,EAA2BvD,EAAMsD,GAClD,EAAK1F,SAAS,CACZe,eAAgBqD,EAAoBtB,OACpC9B,WAAY0E,EAAK5C,OACjB7B,c,EAMJoH,aAAe,WACb,EAAKJ,YADc,IAEX7F,EAAS,EAAK9D,MAAd8D,KACFC,EAAYD,EAAKgE,GAAeC,GAChC/D,EAAUF,EAAKkE,GAAaC,GAC5BnC,EAAsBwB,EAAIxD,EAAMC,EAAWC,GAE3CoD,EAAOQ,EAAW9D,EAAMC,EAAWC,GAEzC,EAAKkF,YAAYpD,EAAqBsB,GACtC,IAAMzE,EAAWkF,EAAmB/D,EAAMsD,GAC1C,EAAK1F,SAAS,CACZe,eAAgBqD,EAAoBtB,OACpC9B,WAAY0E,EAAK5C,OACjB7B,c,EAOJgH,UAAY,WAEV,IADA,IAAMlB,EAAU,EAAKzI,MAAM8D,KAClBnD,EAAM,EAAGA,EAlZH,GAkZqBA,IAClC,IAAK,IAAIC,EAAS,EAAGA,EAlZL,GAkZ6BA,IAC3C6H,EAAQ9H,GAAKC,GAAQsD,SAAWW,IAChC4D,EAAQ9H,GAAKC,GAAQgE,WAAY,EACjC6D,EAAQ9H,GAAKC,GAAQ0E,aAAe,KACpCmD,EAAQ9H,GAAKC,GAAQJ,aAAc,EACnCiI,EAAQ9H,GAAKC,GAAQH,UAAW,EAG3BE,IAAQmH,GAAiBlH,IAAWmH,GACpCpH,IAAQqH,GAAepH,IAAWqH,IACH,IAAhCQ,EAAQ9H,GAAKC,GAAQN,SAGnBmI,EAAQ9H,GAAKC,GAAQL,OAAS,EAChC4I,SAASC,eAAT,eAAgCzI,EAAhC,YAAuCC,IAAUK,UAC/C,sBAEFkI,SAASC,eAAT,eAAgCzI,EAAhC,YAAuCC,IAAUK,UAAY,QAKrE,EAAKS,SAAS,CACZoC,KAAM2E,EACNhG,eAAgB,EAChBC,WAAY,EACZC,SAAU,K,EAKdqH,iBAAmB,WAEjB,IADA,IAAMvB,EAAU,EAAKzI,MAAM8D,KAClBnD,EAAM,EAAGA,EApbH,GAobqBA,IAClC,IAAK,IAAIC,EAAS,EAAGA,EApbL,GAob6BA,IAC3C6H,EAAQ9H,GAAKC,GAAQsD,SAAWW,IAChC4D,EAAQ9H,GAAKC,GAAQgE,WAAY,EACjC6D,EAAQ9H,GAAKC,GAAQ0E,aAAe,KACpCmD,EAAQ9H,GAAKC,GAAQN,QAAS,EAC9BmI,EAAQ9H,GAAKC,GAAQL,OAAS,EAC9BkI,EAAQ9H,GAAKC,GAAQJ,aAAc,EACnCiI,EAAQ9H,GAAKC,GAAQH,UAAW,EAG3BE,IAAQmH,GAAiBlH,IAAWmH,GACpCpH,IAAQqH,GAAepH,IAAWqH,IAGrCkB,SAASC,eAAT,eAAgCzI,EAAhC,YAAuCC,IAAUK,UAAY,QAInE,EAAKS,SAAS,CACZoC,KAAM2E,EACNhG,eAAgB,EAChBC,WAAY,EACZC,SAAU,K,EAIdP,qBAAuB,WAErB,EAAKV,SAAS,CAAEF,YAAa,EAAKxB,MAAMwB,c,EAI1CyI,eAAe,SAACC,GACH,aAAPA,EACF,EAAKxI,SAAS,CAAC6G,YAAY,uEAEb,UAAP2B,EACP,EAAKxI,SAAS,CAAC6G,YAAY,iFAEb,QAAP2B,EACP,EAAKxI,SAAS,CAAC6G,YAAY,wEAEb,QAAP2B,GACP,EAAKxI,SAAS,CAAC6G,YAAY,gF,kEAxc7B,IADA,IAAMzE,EAAO,GACJnD,EAAM,EAAGA,EAxBH,GAwBqBA,IAAO,CAEzC,IADA,IAAMwJ,EAAa,GACVvJ,EAAS,EAAGA,EAzBL,GAyB6BA,IAAU,CACrD,IAAMyF,EAAc,CAClB1F,MACAC,SACAR,QAASO,IAAQmH,GAAiBlH,IAAWmH,EAC7C1H,MAAOM,IAAQqH,GAAepH,IAAWqH,EACzC/D,SAAUW,IACVtE,OAAQ,EACRqE,WAAW,EACXU,aAAc,KACdhF,QAAQ,EACRE,aAAa,EACbC,UAAU,GAEZ0J,EAAW7F,KAAK+B,GAElBvC,EAAKQ,KAAK6F,GAEZzJ,KAAKgB,SAAS,CAAEoC,W,+BAwbR,IAAD,OACCA,EAASpD,KAAKV,MAAd8D,KAER,OAEE,6BACE,kBAAC,EAAD,CACEtC,WAAYd,KAAKV,MAAMwB,WACvBQ,eAAgBtB,KAAKgJ,kBACrBzH,YAAavB,KAAKmJ,eAClB3H,UAAWxB,KAAKoJ,aAChB3H,UAAWzB,KAAKqJ,aAChBxH,qBAAsB7B,KAAKiJ,UAC3BnH,gBAAiB9B,KAAKsJ,iBACtB5H,qBAAsB1B,KAAK0B,qBAC3BkG,cAAe5H,KAAKV,MAAMsI,cAC1B7F,eAAgB/B,KAAKV,MAAMyC,eAC3BE,SAAUjC,KAAKV,MAAM2C,SACrBD,WAAYhC,KAAKV,MAAM0C,WACvBf,kBAAmB,SAACuI,GAAD,OAAQ,EAAKD,eAAeC,MAEjD,yBAAKjJ,UAAU,eACb,wBAAIA,UAAU,wBADhB,eAEE,wBAAIA,UAAU,sBAFhB,aAGE,wBAAIA,UAAU,2BAHhB,iBAIE,wBAAIA,UAAU,gCAJhB,cAKE,wBAAIA,UAAU,wBALhB,kBAME,wBAAIA,UAAU,6BANhB,gBAOE,wBAAIA,UAAU,cAPhB,oBAUA,yBAAKA,UAAU,oBACZP,KAAKV,MAAMuI,aAGd,yBAAKtH,UAAU,QACZ6C,EAAKsG,KAAI,SAACzJ,EAAK0J,GACd,OACE,yBAAKC,IAAKD,GACP1J,EAAIyJ,KAAI,SAAClF,EAAMqF,GACd,OACE,kBAAC,EAAD,CACED,IAAKC,EACL5J,IAAKuE,EAAKvE,IACVC,OAAQsE,EAAKtE,OACbR,QAAS8E,EAAK9E,QACdC,MAAO6E,EAAK7E,MACZ6D,SAAUgB,EAAKhB,SACfU,UAAWM,EAAKN,UAChBU,aAAcJ,EAAKI,aACnBhF,OAAQ4E,EAAK5E,OACbC,OAAQ2E,EAAK3E,OACbC,YAAa0E,EAAK1E,YAClBC,SAAUyE,EAAKzE,SAEfI,YAAa,SAACF,EAAKC,GAAN,OACX,EAAKkI,gBAAgBnI,EAAKC,IAE5BG,aAAc,SAACJ,EAAKC,GAAN,OACZ,EAAKmI,iBAAiBpI,EAAKC,IAE7BE,UAAW,SAACH,EAAKC,GAAN,OACT,EAAKoI,cAAcrI,EAAKC,IAE1BI,aAAc,SAACL,EAAKC,GAAN,OACZ,EAAKqI,iBAAiBtI,EAAIC,cAU1C,yBAAKK,UAAU,eACb,oDAAyB,0BAAMuJ,KAAK,MAAMC,aAAW,OAA5B,0BAA+C,uBAAGC,KAAK,8DAA8DC,OAAO,SAASC,IAAI,uBAA1F,kB,GAxiBhDzJ,aCgInB0J,E,4MAzJX7K,MAAQ,CACJ8K,MAAO,I,0DAKP,IACMC,EAAMrK,KAAKsK,OAAOC,WAAW,MACnCvK,KAAKgB,SAAS,CAAEoJ,MAFD,KAEoB,WAC/BpK,KAAKP,MAAM+K,KAAKxK,KAAKsK,OAAQD,EAAKrK,KAAKV,MAAM8K,Y,8BAMjD,IAAIK,EAAU,GACVC,EAAY,GACZC,EAAa,GACjB,IAAK,IAAI/B,KAAK5I,KAAKV,MAAM8K,MACrBM,EAAU9G,KAAK5D,KAAKV,MAAM8K,MAAMxB,IAChC+B,EAAW/G,KAAK5D,KAAKV,MAAM8K,MAAMxB,IAErC,IAAI9E,EAAS4G,EAAU5G,OACnB8G,EAAQF,EAAU,GAKtB,IAHAD,EAAQ7G,KAAKgH,GACbF,EAAUG,OAAO,EAAG,GAEb/G,EAAS,GAAG,CAGf,IAAIgH,EAAU3G,IACV4G,EAAS,KACTC,EAAgB,KACpB,IAAK,IAAIpC,KAAK6B,EAEV,IAAK,IAAI5B,KAAK6B,EAAW,CACrB,IAAI7K,EAASG,KAAKiL,UAAUR,EAAQ7B,GAAG,GAAI6B,EAAQ7B,GAAG,GAAI8B,EAAU7B,GAAG,GAAI6B,EAAU7B,GAAG,IACpFiC,EAAUjL,IACViL,EAAUjL,EACVmL,EAAgBnC,EAChBkC,EAASnC,GAKrBjH,QAAQC,IAAI6I,EAASC,GACrB1K,KAAKP,MAAMyL,UAAUH,EAAQC,EAAeP,EAASC,EAAW1K,KAAKsK,OAAQtK,KAAKsK,OAAOC,WAAW,OACpGE,EAAQ7G,KAAK8G,EAAUM,IACvBN,EAAUG,OAAOG,EAAe,GAChClH,GAAkB,K,gCAGhBqH,EAAIC,EAAIC,EAAIC,GAClB,IAAIC,EAAIlG,KAAKmG,IAAIL,EAAKE,EAAI,GACtBI,EAAIpG,KAAKmG,IAAIJ,EAAKE,EAAI,GAC1B,OAAOjG,KAAKqG,KAAKH,EAAIE,K,0CAKrB,IAAMpB,EAAMrK,KAAKsK,OAAOC,WAAW,MACnCvK,KAAKP,MAAMkM,QAAQ3L,KAAKsK,OAAQD,K,+BAG1B,IAAD,OACDuB,EAAQC,OAAOC,WAAa,GAC5BC,EAA8B,GAArBF,OAAOG,YAEpB,OACI,yBAAKxL,GAAG,QAEJ,yBAAKD,UAAU,iDACX,yBAAKA,UAAU,sBAAf,0BAOA,yBAAKA,UAAU,2CAAf,wDAGA,yBAAKA,UAAU,sCACX,yCADJ,mBACyC,0CADzC,kBAGA,yBAAKA,UAAU,sCAAf,mBACsB,+CADtB,gBAC8D,kDAD9D,2BAIA,4BAAQA,UAAU,6CAA6CwC,QAAS,WAAQ,EAAKkJ,cACjF,4CAER,4BACI1L,UAAU,0BACVwC,QAAS,SAACmJ,GACN,IAAM7B,EAAM,EAAKC,OAAOC,WAAW,MAC/BH,EAAQ,GACR+B,EAAS,GAMb,GALA/B,EAAMxG,KAAKsI,EAAEE,SACbhC,EAAMxG,KAAKsI,EAAEG,SAEbF,EAAOvI,KAAKwG,GAEoB,IAA5B,EAAK9K,MAAM8K,MAAMtG,OACjB,EAAK9C,SAAS,CAAEoJ,MAAO+B,IAAU,WAE7BnM,KAAKP,MAAM+K,KAAKxK,KAAKsK,OAAQD,EAAKrK,KAAKV,MAAM8K,cAGhD,CACD,IAAIkC,EAAW,EAAKhN,MAAM8K,MAC1BkC,EAAS1I,KAAKuI,EAAO,IACrB,EAAKnL,SAAS,CAAEoJ,MAAOkC,IAAY,WAC/BtM,KAAKP,MAAM+K,KAAKxK,KAAKsK,OAAQD,EAAKrK,KAAKV,MAAM8K,OAC7CpK,KAAKuM,aAOjBC,cAAe,SAACN,GAEZA,EAAEO,iBACF,IAAMpC,EAAM,EAAKC,OAAOC,WAAW,MAC/BmC,EAASR,EAAEE,QACXO,EAAST,EAAEG,QACXjC,EAAQ,EAAK9K,MAAM8K,MAEvB,IAAK,IAAIxB,KAAK,EAAKtJ,MAAM8K,MAAO,CAE5B,GADe/E,KAAKqG,KAAKrG,KAAKmG,IAAIpB,EAAMxB,GAAG,GAAK8D,EAAQ,GAAKrH,KAAKmG,IAAIpB,EAAMxB,GAAG,GAAK+D,EAAQ,IAAM,EACpF,CACVvC,EAAMS,OAAOjC,EAAG,GAChB,OAGR,EAAK5H,SAAS,CAAEoJ,MAAOA,IAAS,WAC5BpK,KAAKP,MAAM+K,KAAKxK,KAAKsK,OAAQD,EAAKrK,KAAKV,MAAM8K,OAC7CpK,KAAKuM,YAKbK,IAAK,SAAApI,GAAI,OAAK,EAAK8F,OAAS9F,GAC5BoH,MAAOA,EACPG,OAAQA,S,GApJPc,IAAMpM,WC8CZqM,G,wDA3CX,WAAYrN,GAAQ,IAAD,8BACjB,cAAMA,IACDsN,aAAeF,IAAMG,YAFT,E,qDAOjB,OACI,oCACA,kBAAC,EAAD,CACEpB,MAAO,KACPG,OAAQ,IACRJ,QAAS,SAACrB,EAAQD,GAChBA,EAAI4C,WAAY,EAAG,EAAG3C,EAAOsB,MAAOtB,EAAOyB,SAE7CvB,KAAM,SAACF,EAAQD,EAAKD,GAClB,IAAI8C,EAAO5C,EAAO6C,wBAGlB,IAAK,IAAIvE,KAFTyB,EAAI+C,UAAW,EAAG,EAAG9C,EAAOsB,MAAOtB,EAAOyB,QAC1C1B,EAAI4C,WAAY,EAAG,EAAG3C,EAAOsB,MAAOtB,EAAOyB,QAC7B3B,EACZC,EAAIgD,UAAY,UAChBhD,EAAIiD,YACJjD,EAAIkD,IAAInD,EAAMxB,GAAG,GAAGsE,EAAKM,KAAOpD,EAAMxB,GAAG,GAAGsE,EAAKO,IAAM,GAAI,EAAG,EAAIpI,KAAKqI,IACvErD,EAAIsD,QAKRzC,UAAW,SAAC0C,EAAQC,EAAapD,EAASC,EAAWJ,EAAQD,GAC3D,IAAI6C,EAAO5C,EAAO6C,wBAClB9C,EAAIyD,YAAc,UAClBzD,EAAIiD,YACJjD,EAAI0D,OAAOtD,EAAQmD,GAAQ,GAAKV,EAAKM,KAAM/C,EAAQmD,GAAQ,GAAGV,EAAKO,KACnEpD,EAAI2D,OAAOtD,EAAUmD,GAAa,GAAGX,EAAKM,KAAO9C,EAAUmD,GAAa,GAAIX,EAAKO,KACjFpD,EAAI4D,iB,GApCkBpB,IAAMpM,Y,eC8B3ByN,EA7BA,WAEX,OACE,kBAACvL,EAAA,EAAD,CAAKwL,SAAO,EAAC/L,QAAQ,QAAQgM,iBAAiB,OAAO7N,UAAU,uCAAuC+B,OAAO,OAC7G,kBAACK,EAAA,EAAIG,KAAL,KACE,kBAAC,IAAD,CAAMuL,GAAG,QACL,kBAAC1L,EAAA,EAAI2L,KAAL,CAAUtE,KAAK,QAAf,6BAKN,kBAACrH,EAAA,EAAIG,KAAL,KACE,kBAAC,IAAD,CAAMuL,GAAG,QACL,kBAAC1L,EAAA,EAAI2L,KAAL,CAAUtE,KAAK,OAAOuE,SAAS,UAA/B,6BCiBGC,E,4MAvBblP,MAAQ,G,uDAEN,OAEE,kBAAC,IAAD,KAEK,kBAAC,EAAD,MACC,kBAAC,IAAD,KACA,kBAAC,IAAD,CAAOmP,OAAK,EAAC/H,KAAK,IAAIgI,QAAS,kBAAC,EAAD,QAC7B,kBAAC,IAAD,CAAOD,OAAK,EAAC/H,KAAK,yBAAyBgI,QAAS,kBAAC,EAAD,QACpD,kBAAC,IAAD,CAAOD,OAAK,EAAC/H,KAAK,OAAOgI,QAAS,kBAAC,EAAD,QAClC,kBAAC,IAAD,CAAOD,OAAK,EAAC/H,KAAK,OAAOgI,QAAS,kBAAC,EAAD,c,GAZ9BjO,aCCEkO,QACW,cAA7B9C,OAAO+C,SAASC,UAEe,UAA7BhD,OAAO+C,SAASC,UAEhBhD,OAAO+C,SAASC,SAASC,MACvB,2D,YCXNC,IAAQC,WAAW,kBACnBD,IAAQE,SAASpD,OAAO+C,SAASM,SAAWrD,OAAO+C,SAASO,QAC5DC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEF7G,SAASC,eAAe,SDsHpB,kBAAmB6G,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLnO,QAAQmO,MAAMA,EAAMC,c","file":"static/js/main.99681d38.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport \"./node.css\";\r\n\r\nclass Node extends Component {\r\n  state = {};\r\n  getClassName = () => {\r\n    let str = \"node\";\r\n    if (this.props.isStart === true) {\r\n      str = str + \" startNode\";\r\n    } else if (this.props.isEnd === true) {\r\n      str = str + \" endNode\";\r\n    } else if (this.props.isWall === true) {\r\n      str = str + \" wall-true\";\r\n    } else if (this.props.weight > 0) {\r\n      str = str + \" weight-present\";\r\n    }\r\n    if (this.props.visitedNode === true){\r\n      str = str + \" node-visited\";\r\n    }\r\n    if (this.props.pathNode === true){\r\n      str = str + \" node-shortestPath\";\r\n    }\r\n    if (this.props.pathNode === true && this.props.weight > 0){\r\n      str = \"node weight-present-path\";\r\n    }\r\n    else if (this.props.visitedNode === true && this.props.weight > 0){\r\n      str = \"node weight-present-visited\";\r\n    }\r\n    return str; \r\n  };\r\n\r\n  render() {\r\n    const {\r\n      row,\r\n      column,\r\n      // isStart,\r\n      // isEnd,\r\n      // distance,\r\n      // isVisited,\r\n      // previousNode,\r\n      // isWall,\r\n      // weight,\r\n      onMouseDown,\r\n      onMouseUp,\r\n      onMouseEnter,\r\n      onMouseLeave,\r\n    } = this.props;\r\n    //console.log(  this.props);\r\n    return (\r\n      <div\r\n        className={this.getClassName()}\r\n        id={`node-${row}-${column}`}\r\n        onMouseDown={() => onMouseDown(row, column)}\r\n        onMouseEnter={() => onMouseEnter(row, column)}\r\n        onMouseUp={() => onMouseUp(row, column)}\r\n        onMouseLeave={() => onMouseLeave(row,column)}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Node;\r\n","import React, { Component } from \"react\";\r\nimport Navbar from \"react-bootstrap/Navbar\";\r\nimport Nav from \"react-bootstrap/Nav\";\r\nimport NavDropdown from \"react-bootstrap/NavDropdown\";\r\nimport Button from \"react-bootstrap/Button\";\r\nimport \"./graphAlgoVisualizer.css\";\r\n\r\nconst Checkbox = (props) => <input type=\"checkbox\" {...props} />;\r\n\r\nclass classNavbar extends Component {\r\n  state = {\r\n    currentAlgo: \"Choose Algorithm\",\r\n    addWeights: \"false\",\r\n  };\r\n  forDijkstra = () => {\r\n    this.setState({ currentAlgo: \"Dijkstra\" });\r\n    this.props.handleDescription(\"Dijkstra\");\r\n  };\r\n  forAstar = () => {\r\n    this.setState({ currentAlgo: \"A* Search\" });\r\n    this.props.handleDescription(\"Astar\");\r\n  };\r\n  forBFS = () => {\r\n    this.setState({ currentAlgo: \"Breadth First Search\" });\r\n    this.props.handleDescription(\"BFS\");\r\n  };\r\n  forDFS = () => {\r\n    this.setState({ currentAlgo: \"Depth First Search\" });\r\n    this.props.handleDescription(\"DFS\");\r\n  };\r\n  visualize = () => {\r\n    if (this.state.currentAlgo === \"Dijkstra\") {\r\n      this.props.handleDijkstra();\r\n    } else if (this.state.currentAlgo === \"A* Search\") {\r\n      this.props.handleAstar();\r\n    } else if (this.state.currentAlgo === \"Breadth First Search\") {\r\n      this.props.handleBFS();\r\n    } else if (this.state.currentAlgo === \"Depth First Search\") {\r\n      this.props.handleDFS();\r\n    }\r\n  };\r\n  handleCheckboxChange = () => {\r\n    console.log(this.state.addWeights);\r\n    this.setState({ addWeights: !this.state.addWeights });\r\n    // console.log(this.state.addWeights, \"hi\");\r\n  };\r\n  render() {\r\n    const {\r\n      handleClearAlgorithm,\r\n      handleClearGrid,\r\n      addWeights,\r\n      handleCheckboxChange,\r\n      timeComplexity,\r\n      pathLength,\r\n      pathCost,\r\n    } = this.props;\r\n    return (\r\n      <Navbar bg=\"dark\" variant=\"dark\" expand=\"lg\" sticky=\"top\">\r\n        <Navbar.Brand className=\"mr-4\">Path Finding Visualizer</Navbar.Brand>\r\n        <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\r\n        <Navbar.Collapse id=\"basic-navbar-nav\">\r\n          <Nav className=\"mr-auto\">\r\n            {/* <Nav.Link href=\"#home\">Home</Nav.Link>\r\n            <Nav.Link href=\"#link\">Link</Nav.Link> */}\r\n            <NavDropdown title={this.state.currentAlgo} id=\"basic-nav-dropdown\">\r\n              <NavDropdown.Item onClick={this.forDijkstra}>\r\n                Dijkstra\r\n              </NavDropdown.Item>\r\n              <NavDropdown.Item onClick={this.forAstar}>\r\n                A* Search\r\n              </NavDropdown.Item>\r\n              <NavDropdown.Item onClick={this.forBFS}>\r\n                Breadth First Search\r\n              </NavDropdown.Item>\r\n              <NavDropdown.Item onClick={this.forDFS}>\r\n                Depth First Search\r\n              </NavDropdown.Item>\r\n              {/* <NavDropdown.Divider />\r\n              <NavDropdown.Item\">\r\n                Separated link\r\n              </NavDropdown.Item> */}\r\n            </NavDropdown>\r\n            <Button\r\n              variant=\"success\"\r\n              className=\"mx-4\"\r\n              onClick={this.visualize}\r\n              id=\"visualize\"\r\n            >\r\n              Visualize!\r\n            </Button>\r\n            <Button\r\n              variant=\"info\"\r\n              className=\"mx-4\"\r\n              id=\"clearAlgo\"\r\n              onClick={handleClearAlgorithm}\r\n            >\r\n              Clear Algorithm\r\n            </Button>\r\n            <Button\r\n              variant=\"info\"\r\n              className=\"mx-4\"\r\n              onClick={handleClearGrid}\r\n              id=\"clearGrid\"\r\n            >\r\n              Clear Grid\r\n            </Button>\r\n            <label className=\"mx-3\">\r\n              <Checkbox checked={addWeights} onChange={handleCheckboxChange} />\r\n              <span className=\"checkBox\">Switch to Weights</span>\r\n            </label>\r\n            <label className=\"checkBox mx-3\">Path Length : {pathLength}</label>\r\n            <label className=\"checkBox mx-3\">Path Cost : {pathCost}</label>\r\n            <label className=\"checkBox mx-3\">Time Complexity : {timeComplexity}</label>\r\n          </Nav>\r\n        </Navbar.Collapse>\r\n      </Navbar>\r\n    );\r\n  }\r\n}\r\n\r\nexport default classNavbar;\r\n","export function dijkstra(grid, startNode, endNode) {\r\n  const visitedNodeInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  // console.log(unvisitedNodes);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const nearestNode = unvisitedNodes.shift();\r\n    nearestNode.isVisited = true;\r\n    if (nearestNode.distance === Infinity) {\r\n      return visitedNodeInOrder;\r\n    }\r\n    if (nearestNode.isWall === true) {\r\n      continue;\r\n    }\r\n    // nearestNode.isVisited = true;\r\n    visitedNodeInOrder.push(nearestNode);\r\n    if (nearestNode === endNode) {\r\n      return visitedNodeInOrder;\r\n    }\r\n    updateUnvisitedNeighbours(nearestNode, grid);\r\n    // console.log(visitedNodeInOrder);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbours(node, grid) {\r\n  const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\r\n  for (let ite of unvisitedNeighbours) {\r\n    if (ite.distance > node.distance + ite.weight) {\r\n      ite.distance = node.distance + ite.weight + 1;\r\n      ite.previousNode = node;\r\n    }\r\n  }\r\n  return unvisitedNeighbours;\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  const unvisitedNeighbours = [];\r\n  const { row, column } = node;\r\n  if (row - 1 >= 0 && grid[row - 1][column].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row - 1][column]);\r\n\r\n  if (row + 1 < grid.length && grid[row + 1][column].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row + 1][column]);\r\n\r\n  if (column - 1 >= 0 && grid[row][column - 1].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row][column - 1]);\r\n\r\n  if (column + 1 < grid[0].length && grid[row][column + 1].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row][column + 1]);\r\n\r\n  return unvisitedNeighbours;\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  let nodes = [];\r\n  for (let row of grid) {\r\n    for (let columns of row) {\r\n      nodes.push(columns);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function getShortestPathDijkstra(grid, startNode, endNode) {\r\n  const shortestPath = [];\r\n  let previous = endNode.previousNode;\r\n  if (previous === null) {\r\n    return shortestPath;\r\n  }\r\n  while (previous !== startNode) {\r\n    shortestPath.push(previous);\r\n    previous = previous.previousNode;\r\n  }\r\n  shortestPath.reverse();\r\n  return shortestPath;\r\n}\r\n\r\nexport function getWeightOfShortestPathDijkstra(grid, shortestPath) {\r\n  let weightOfPath = 0;\r\n  for (let ite of shortestPath) {\r\n    if (ite.weight === 0) {\r\n      weightOfPath = weightOfPath + 1;\r\n    } else {\r\n      weightOfPath = weightOfPath + ite.weight + 1;\r\n    }\r\n  }\r\n  return weightOfPath;\r\n}\r\n","//here distance is f in a* algo\r\n//f=g+h\r\nexport function aStar(grid, startNode, endNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance =\r\n    Math.abs(startNode.row - endNode.row) +\r\n    Math.abs(startNode.column - endNode.column);\r\n  // startNode.distance=0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByValueF(unvisitedNodes);\r\n    const nextNode = unvisitedNodes.shift();\r\n    if (nextNode.distance === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (nextNode.isWall) {\r\n      continue;\r\n    }\r\n    nextNode.isVisited = true;\r\n    visitedNodesInOrder.push(nextNode);\r\n    if (nextNode === endNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    updateUnvisitedNeighbours(nextNode, endNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByValueF(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const toReturn = [];\r\n  for (let rows of grid) {\r\n    for (let columns of rows) {\r\n      toReturn.push(columns);\r\n    }\r\n  }\r\n  return toReturn;\r\n}\r\n\r\nfunction updateUnvisitedNeighbours(currentNode, targetNode, grid) {\r\n  const unvisitedNeighbours = getUnvisitedNeighbours(currentNode, grid);\r\n  const distanceBetweenCurrentAndTarget =\r\n    Math.abs(currentNode.row - targetNode.row) +\r\n    Math.abs(currentNode.column - targetNode.column);\r\n  const g_currentNode = currentNode.distance - distanceBetweenCurrentAndTarget;\r\n  for (let ite of unvisitedNeighbours) {\r\n    let g_ite = g_currentNode + ite.weight + 1;\r\n    let h_ite =\r\n      Math.abs(ite.row - targetNode.row) +\r\n      Math.abs(ite.column - targetNode.column);\r\n    if (ite.distance > g_ite + h_ite) {\r\n      ite.distance = g_ite + h_ite;\r\n      ite.previousNode = currentNode;\r\n    }\r\n  }\r\n  return unvisitedNeighbours;\r\n}\r\n\r\n// function updateUnvisitedNeighbours(currentNode, targetNode, grid) {\r\n//   const unvisitedNeighbours = getUnvisitedNeighbours(currentNode, grid);\r\n//   const distanceBetweenCurrentAndTarget =\r\n//     currentNode.distance -\r\n//     (Math.abs(currentNode.row - targetNode.row) +\r\n//       Math.abs(currentNode.column - targetNode.column));\r\n//   // const distanceBetweenCurrentAndTarget = currentNode.distance;\r\n//   for (let ite of unvisitedNeighbours) {\r\n//     if (\r\n//       ite.distance >\r\n//       distanceBetweenCurrentAndTarget +\r\n//         ite.weight +\r\n//         Math.abs(ite.row - targetNode.row) +\r\n//         Math.abs(ite.column - targetNode.column)\r\n//     ) {\r\n//       ite.distance =\r\n//         distanceBetweenCurrentAndTarget +\r\n//         ite.weight +\r\n//         Math.abs(ite.row - targetNode.row) +\r\n//         Math.abs(ite.column - targetNode.column);\r\n//       ite.previousNode = currentNode;\r\n//     }\r\n//   }\r\n//   return unvisitedNeighbours;\r\n// }\r\n\r\nfunction getUnvisitedNeighbours(currentNode, grid) {\r\n  const unvisitedNeighbours = [];\r\n  const { row, column } = currentNode;\r\n  if (row - 1 >= 0 && grid[row - 1][column].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row - 1][column]);\r\n\r\n  if (row + 1 < grid.length && grid[row + 1][column].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row + 1][column]);\r\n\r\n  if (column - 1 >= 0 && grid[row][column - 1].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row][column - 1]);\r\n\r\n  if (column + 1 < grid[0].length && grid[row][column + 1].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row][column + 1]);\r\n\r\n  return unvisitedNeighbours;\r\n}\r\n\r\nexport function getShortestPathAstar(grid, startNode, endNode) {\r\n  const shortestPath = [];\r\n  let previous = endNode.previousNode;\r\n  if (previous === null) {\r\n    return shortestPath;\r\n  }\r\n  while (previous !== startNode) {\r\n    shortestPath.push(previous);\r\n    previous = previous.previousNode;\r\n  }\r\n  shortestPath.reverse();\r\n  return shortestPath;\r\n}\r\n\r\nexport function getWeightOfShortestPathAstar(grid, shortestPath) {\r\n  let weightOfPath = 0;\r\n  for (let ite of shortestPath) {\r\n    if (ite.weight === 0) {\r\n      weightOfPath = weightOfPath + 1;\r\n    } else {\r\n      weightOfPath = weightOfPath + ite.weight + 1;\r\n    }\r\n  }\r\n  return weightOfPath;\r\n}\r\n","export function bfs(grid, startNode, endNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.isVisited = true;\r\n  //    const unvisitedNodes=extractAllNodes(grid);\r\n  const queue = [];\r\n  queue.push(startNode);\r\n  while (!!queue.length) {\r\n    const currNode = queue.shift();\r\n    if (currNode === endNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (currNode.isWall) {\r\n      continue;\r\n    }\r\n    visitedNodesInOrder.push(currNode);\r\n    pushNeighboursOfCurrentNode(grid, queue, currNode);\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction pushNeighboursOfCurrentNode(grid, queue, currNode) {\r\n  const neighboursOfCurrentNode = getNeighboursOfCurrentNode(grid, currNode);\r\n  for (let node of neighboursOfCurrentNode) {\r\n    node.isVisited = true;\r\n    node.previousNode = currNode;\r\n    queue.push(node);\r\n  }\r\n}\r\n\r\nfunction getNeighboursOfCurrentNode(grid, currNode) {\r\n  const toReturn = [];\r\n  const row = currNode.row;\r\n  const column = currNode.column;\r\n\r\n  if (row - 1 >= 0 && !grid[row - 1][column].isVisited)\r\n    toReturn.push(grid[row - 1][column]);\r\n\r\n  if (column - 1 >= 0 && !grid[row][column - 1].isVisited)\r\n    toReturn.push(grid[row][column - 1]);\r\n\r\n  if (row + 1 < grid.length && !grid[row + 1][column].isVisited)\r\n    toReturn.push(grid[row + 1][column]);\r\n\r\n  if (column + 1 < grid[0].length && !grid[row][column + 1].isVisited)\r\n    toReturn.push(grid[row][column + 1]);\r\n\r\n  return toReturn;\r\n}\r\n\r\n// function extractAllNodes(grid){\r\n//     const toReturn=[];\r\n//     for (let row of grid){\r\n//         for (let column of row){\r\n//             toReturn.push(column);\r\n//         }\r\n//     }\r\n//     return toReturn;\r\n// }\r\n\r\nexport function getPathBFS(grid, startNode, endNode) {\r\n  const path = [];\r\n  let previous = endNode.previousNode;\r\n  if (previous === null) {\r\n    return path;\r\n  }\r\n  while (previous !== startNode) {\r\n    path.push(previous);\r\n    previous = previous.previousNode;\r\n  }\r\n  path.reverse();\r\n  return path;\r\n}\r\n\r\nexport function getWeightOfShortestPathBFS(grid, path) {\r\n  let weightOfPath = 0;\r\n  for (let ite of path) {\r\n    if (ite.weight === 0) {\r\n      weightOfPath = weightOfPath + 1;\r\n    } else {\r\n      weightOfPath = weightOfPath + ite.weight + 1;\r\n    }\r\n  }\r\n  return weightOfPath;\r\n}\r\n","export function dfs(grid, startNode, endNode) {\r\n  const visitedNodesInOrder = [];\r\n  const stack = [];\r\n  startNode.isVisited = true;\r\n  stack.push(startNode);\r\n  while (!!stack.length) {\r\n    const nextNode = stack.pop();\r\n    if (nextNode.isWall === true) {\r\n      continue;\r\n    }\r\n    visitedNodesInOrder.push(nextNode);\r\n    if (nextNode === endNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    pushNeighboursOfNode(grid, stack, nextNode);\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction pushNeighboursOfNode(grid, stack, node) {\r\n  const neighboursOfNode = getNeighboursOfNode(grid, node);\r\n  for (let ite of neighboursOfNode) {\r\n    if (ite.previousNode===null){\r\n      ite.previousNode = node;\r\n    }\r\n    ite.isVisited = true;\r\n    stack.push(ite);\r\n  }\r\n}\r\n\r\nfunction getNeighboursOfNode(grid, node) {\r\n  const unvisitedNeighbours = [];\r\n  const row = node.row;\r\n  const column = node.column;\r\n\r\n  if (row - 1 >= 0 && grid[row - 1][column].isVisited === false) {\r\n    unvisitedNeighbours.push(grid[row - 1][column]);\r\n  }\r\n  if (column - 1 >= 0 && grid[row][column - 1].isVisited === false) {\r\n    unvisitedNeighbours.push(grid[row][column - 1]);\r\n  }\r\n  if (row + 1 < grid.length && grid[row + 1][column].isVisited === false) {\r\n    unvisitedNeighbours.push(grid[row + 1][column]);\r\n  }\r\n  if (\r\n    column + 1 < grid[0].length &&\r\n    grid[row][column + 1].isVisited === false\r\n  ) {\r\n    unvisitedNeighbours.push(grid[row][column + 1]);\r\n  }\r\n\r\n  return unvisitedNeighbours;\r\n}\r\n\r\nexport function getPathDFS(grid, startNode, endNode) {\r\n  const path = [];\r\n  let previous = endNode.previousNode;\r\n  if (previous === null) {\r\n    return path;\r\n  }\r\n  while (previous !== startNode) {\r\n    path.push(previous);\r\n    previous = previous.previousNode;\r\n  }\r\n  path.reverse();\r\n  return path;\r\n}\r\n\r\nexport function getWeightOfPathDFS(grid, path) {\r\n  let weightOfPath = 0;\r\n  for (let ite of path) {\r\n    if (ite.weight === 0) {\r\n      weightOfPath = weightOfPath + 1;\r\n    } else {\r\n      weightOfPath = weightOfPath + ite.weight + 1;\r\n    }\r\n  }\r\n  return weightOfPath;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./node/node.jsx\";\r\nimport Navbar from \"./navbar\";\r\nimport \"./graphAlgoVisualizer.css\";\r\nimport {\r\n  dijkstra,\r\n  getShortestPathDijkstra,\r\n  getWeightOfShortestPathDijkstra,\r\n} from \"../algorithms/dijkstra.js\";\r\nimport {\r\n  aStar,\r\n  getShortestPathAstar,\r\n  getWeightOfShortestPathAstar,\r\n} from \"../algorithms/aStar.js\";\r\nimport {\r\n  bfs,\r\n  getPathBFS,\r\n  getWeightOfShortestPathBFS,\r\n} from \"../algorithms/bfs.js\";\r\nimport { dfs, getPathDFS, getWeightOfPathDFS } from \"../algorithms/dfs\";\r\nimport \"./node/node.css\";\r\n\r\nconst total_rows = 18;\r\nconst total_columns = 45;\r\nvar startNode_Row = 5;\r\nvar startNode_Col = 10;\r\nvar endNode_Row = 10;\r\nvar endNode_Col = 37;\r\nconst FixedWeight = 10;\r\n\r\nclass GraphAlgoVisualizer extends Component {\r\n  state = {\r\n    grid: [],\r\n    isMousePressed: false,\r\n    timeComplexity: 0,\r\n    pathCost: 0,\r\n    pathLength: 0,\r\n    isMovingStart: false,\r\n    isMovingEnd: false,\r\n    addWeights: false,\r\n    processActive: false,\r\n    description: \"Selecting the Nodes in the grid creates Obstacles/Weights. To switch from Obstacles to Weight and vice versa, use the checkbox at Navbar and select an Algorithm\",\r\n  };\r\n\r\n  componentDidMount() {\r\n    const grid = [];\r\n    for (let row = 0; row < total_rows; row++) {\r\n      const currentRow = [];\r\n      for (let column = 0; column < total_columns; column++) {\r\n        const currentNode = {\r\n          row,\r\n          column,\r\n          isStart: row === startNode_Row && column === startNode_Col,\r\n          isEnd: row === endNode_Row && column === endNode_Col,\r\n          distance: Infinity,\r\n          weight: 0,\r\n          isVisited: false,\r\n          previousNode: null,\r\n          isWall: false,\r\n          visitedNode: false,\r\n          pathNode: false,\r\n        };\r\n        currentRow.push(currentNode);\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    this.setState({ grid });\r\n  }\r\n\r\n  getNewGridWithWallToggled = (row, column) => {\r\n    const newGrid = this.state.grid.slice();\r\n    const node = newGrid[row][column];\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n      weight: 0,\r\n    };\r\n    newGrid[row][column] = newNode;\r\n    return newGrid;\r\n  };\r\n\r\n  getNewGridWithWeights = (row, column) => {\r\n    const newGrid = this.state.grid.slice();\r\n    const node = newGrid[row][column];\r\n    let changeInValue = 0;\r\n    if (node.weight === 0) {\r\n      changeInValue = FixedWeight;\r\n    } else {\r\n      changeInValue = -FixedWeight;\r\n    }\r\n    const newNode = {\r\n      ...node,\r\n      isWall: false,\r\n      weight: node.weight + changeInValue,\r\n    };\r\n    newGrid[row][column] = newNode;\r\n    return newGrid;\r\n  };\r\n\r\n  handleMouseDown = (row, column) => {\r\n    if (this.state.processActive === true) {\r\n      return;\r\n    }\r\n    if (\r\n      !(\r\n        (row === startNode_Row && column === startNode_Col) ||\r\n        (row === endNode_Row && column === endNode_Col)\r\n      )\r\n    ) {\r\n      // console.log(row, column, \"mouse down\");\r\n      let newGrid;\r\n      if (!this.state.addWeights) {\r\n        newGrid = this.getNewGridWithWallToggled(row, column);\r\n      } else {\r\n        newGrid = this.getNewGridWithWeights(row, column);\r\n      }\r\n      this.setState({ grid: newGrid, isMousePressed: true });\r\n    }\r\n    // if user wants to change positon of start or end node\r\n    else {\r\n      // console.log(row, column, \"mouse down starting or ending\");\r\n      this.setState({ isMousePressed: true });\r\n      if (row === startNode_Row && column === startNode_Col) {\r\n        const newGrid = this.state.grid.slice();\r\n        const node = newGrid[row][column];\r\n        const newNode = {\r\n          ...node,\r\n          isStart: false,\r\n        };\r\n        newGrid[row][column] = newNode;\r\n        this.setState({ grid: newGrid, isMovingStart: true });\r\n      } else if (row === endNode_Row && column === endNode_Col) {\r\n        const newGrid = this.state.grid.slice();\r\n        const node = newGrid[row][column];\r\n        const newNode = {\r\n          ...node,\r\n          isEnd: false,\r\n        };\r\n        newGrid[row][column] = newNode;\r\n        this.setState({ grid: newGrid, isMovingEnd: true });\r\n      }\r\n    }\r\n  };\r\n\r\n  handleMouseEnter = (row, column) => {\r\n    //Mouse entering a node with no click\r\n    if (!this.state.isMousePressed && !this.state.processActive) {\r\n      if (\r\n        !(\r\n          (row === startNode_Row && column === startNode_Col) ||\r\n          (row === endNode_Row && column === endNode_Col)\r\n        )\r\n      ) {\r\n        // console.log(row, column, \"mouse enter\");\r\n        let newGrid;\r\n        if (!this.state.addWeights) {\r\n          newGrid = this.getNewGridWithWallToggled(row, column);\r\n        } else {\r\n          newGrid = this.getNewGridWithWeights(row, column);\r\n        }\r\n        this.setState({ grid: newGrid });\r\n      } else {\r\n        // console.log(\"mouse entered starting or ending\");\r\n      }\r\n      return;\r\n    }\r\n\r\n  //  if (this.state.isMovingStart || this.state.isMovingEnd) return;\r\n    if (this.state.isMovingStart){\r\n      const newGrid=this.state.grid;\r\n      newGrid[startNode_Row][startNode_Col].isStart=false;\r\n      newGrid[row][column].isStart=true;\r\n      startNode_Row=row;\r\n      startNode_Col=column;\r\n      this.setState({grid:newGrid});\r\n    }\r\n    else if (this.state.isMovingEnd){\r\n      const newGrid=this.state.grid;\r\n      newGrid[endNode_Row][endNode_Col].isEnd=false;\r\n      newGrid[row][column].isEnd=true;\r\n      endNode_Row=row;\r\n      endNode_Col=column;\r\n      this.setState({grid:newGrid});\r\n    }\r\n    if (\r\n      this.state.isMousePressed &&\r\n      !(\r\n        (row === startNode_Row && column === startNode_Col) ||\r\n        (row === endNode_Row && column === endNode_Col)\r\n      )\r\n    ) {\r\n      // console.log(row, column, \"mouse enter\");\r\n      let newGrid;\r\n      if (!this.state.addWeights) {\r\n        newGrid = this.getNewGridWithWallToggled(row, column);\r\n      } else {\r\n        newGrid = this.getNewGridWithWeights(row, column);\r\n      }\r\n      this.setState({ grid: newGrid });\r\n    } else {\r\n      // console.log(\"mouse entered starting or ending\");\r\n    }\r\n  };\r\n\r\n  handleMouseUp = (row, column) => {\r\n    if (this.state.processActive === true) {\r\n      return;\r\n    }\r\n    // console.log(\"mouse up\");\r\n    this.setState({ isMousePressed: false });\r\n\r\n    //if moving start or end\r\n    if (this.state.isMovingStart === true) {\r\n      const newGrid = this.state.grid.slice();\r\n      const node = newGrid[row][column];\r\n      const newNode = {\r\n        ...node,\r\n        isWall: false,\r\n        isStart: true,\r\n      };\r\n      newGrid[row][column] = newNode;\r\n      this.setState({ grid: newGrid, isMovingStart: false });\r\n      startNode_Row = row;\r\n      startNode_Col = column;\r\n    } else if (this.state.isMovingEnd === true) {\r\n      const newGrid = this.state.grid.slice();\r\n      const node = newGrid[row][column];\r\n      const newNode = {\r\n        ...node,\r\n        isWall: false,\r\n        isEnd: true,\r\n      };\r\n      newGrid[row][column] = newNode;\r\n      this.setState({ grid: newGrid, isMovingEnd: false });\r\n      endNode_Row = row;\r\n      endNode_Col = column;\r\n    }\r\n  };\r\n\r\n  handleMouseLeave = (row, column) => {\r\n    if (!this.state.isMousePressed && !this.state.processActive) {\r\n      if (\r\n        !(\r\n          (row === startNode_Row && column === startNode_Col) ||\r\n          (row === endNode_Row && column === endNode_Col)\r\n        )\r\n      ) {\r\n        // console.log(row, column, \"mouse enter\");\r\n        let newGrid;\r\n        if (!this.state.addWeights) {\r\n          newGrid = this.getNewGridWithWallToggled(row, column);\r\n        } else {\r\n          newGrid = this.getNewGridWithWeights(row, column);\r\n        }\r\n        this.setState({ grid: newGrid });\r\n      } else {\r\n        // console.log(\"mouse entered starting or ending\");\r\n      }\r\n      return;\r\n    }\r\n  };\r\n\r\n  animateAlgo = (visitedNodesInOrder, shortestPath) => {\r\n    this.setState({ processActive: true });\r\n    document.getElementById(\"visualize\").disabled = true;\r\n    document.getElementById(\"clearAlgo\").disabled = true;\r\n    document.getElementById(\"clearGrid\").disabled = true;\r\n    const newGrid = this.state.grid.slice();\r\n    for (let i = 1; i < visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        for (let j = 0; j < shortestPath.length; j++) {\r\n          setTimeout(() => {\r\n            setTimeout(() => {\r\n              const node = shortestPath[j];\r\n              // if (j===0){\r\n              //   console.log(node);\r\n              // }\r\n              const newGridNode = newGrid[node.row][node.column];\r\n              const newNode = {\r\n                ...newGridNode,\r\n                pathNode: true,\r\n              };\r\n              newGrid[node.row][node.column] = newNode;\r\n              // this.setState({ grid: newGrid});\r\n              if (\r\n                document.getElementById(`node-${node.row}-${node.column}`)\r\n                  .className === \"node weight-present-visited\"\r\n              ) {\r\n                document.getElementById(\r\n                  `node-${node.row}-${node.column}`\r\n                ).className = \"node weight-present-path\";\r\n              } else {\r\n                document.getElementById(\r\n                  `node-${node.row}-${node.column}`\r\n                ).className = \"node node-shortestPath\";\r\n              }\r\n            }, 50 * j);\r\n          }, 25 * i);\r\n        }\r\n        // Finally the solution to bug\r\n        setTimeout(() => {\r\n          setTimeout(() => {\r\n            this.setState({ processActive: false });\r\n            document.getElementById(\"visualize\").disabled = false;\r\n            document.getElementById(\"clearAlgo\").disabled = false;\r\n            document.getElementById(\"clearGrid\").disabled = false;\r\n            this.setState({ grid: newGrid});\r\n          }, 50 * shortestPath.length);\r\n        }, 25 * visitedNodesInOrder.length);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        // const newGrid = this.state.grid.slice();\r\n              const newGridNode = newGrid[node.row][node.column];\r\n              const newNode = {\r\n                ...newGridNode,\r\n                visitedNode: true,\r\n              };\r\n              newGrid[node.row][node.column] = newNode;\r\n              // this.setState({ grid: newGrid});\r\n        if (\r\n          document.getElementById(`node-${node.row}-${node.column}`)\r\n            .className === \"node weight-present\"\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.column}`).className =\r\n            \"node weight-present-visited\";\r\n        } else {\r\n          document.getElementById(`node-${node.row}-${node.column}`).className =\r\n            \"node node-visited\";\r\n        }\r\n      }, 25 * i);\r\n    }\r\n  };\r\n\r\n  visualizeDijkstra = () => {\r\n    // const toBeDisabled = document.getElementById(\"button\");\r\n    // toBeDisabled.disabled = true;\r\n    this.clearAlgo(); //for clearing grid for any previous algo if implemented\r\n    const { grid } = this.state;\r\n    const startNode = grid[startNode_Row][startNode_Col];\r\n    const endNode = grid[endNode_Row][endNode_Col];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    const shortestPath = getShortestPathDijkstra(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    const shortestPathCost = getWeightOfShortestPathDijkstra(\r\n      grid,\r\n      shortestPath\r\n    );\r\n    this.animateAlgo(visitedNodesInOrder, shortestPath);\r\n    this.setState({\r\n      timeComplexity: visitedNodesInOrder.length,\r\n      pathLength: shortestPath.length,\r\n      pathCost: shortestPathCost,\r\n    });\r\n    // toBeDisabled.disabled = false;\r\n    // console.log(shortestPath);\r\n    // console.log(grid);\r\n  };\r\n\r\n  visualizeAstar = () => {\r\n    this.clearAlgo(); //for clearing grid for any previous algo if implemented\r\n    const { grid } = this.state;\r\n    const startNode = grid[startNode_Row][startNode_Col];\r\n    const endNode = grid[endNode_Row][endNode_Col];\r\n    const visitedNodesInOrder = aStar(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    const shortestPath = getShortestPathAstar(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    const shortestPathCost = getWeightOfShortestPathAstar(grid, shortestPath);\r\n    this.animateAlgo(visitedNodesInOrder, shortestPath);\r\n    this.setState({\r\n      timeComplexity: visitedNodesInOrder.length,\r\n      pathLength: shortestPath.length,\r\n      pathCost: shortestPathCost,\r\n    });\r\n    // console.log(shortestPath);\r\n    // console.log(grid);\r\n  };\r\n\r\n  visualizeBFS = () => {\r\n    this.clearAlgo(); //for clearing grid for any previous algo if implemented\r\n    const { grid } = this.state;\r\n    const startNode = grid[startNode_Row][startNode_Col];\r\n    const endNode = grid[endNode_Row][endNode_Col];\r\n    const visitedNodesInOrder = bfs(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    const path = getPathBFS(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    this.animateAlgo(visitedNodesInOrder, path);\r\n    const pathCost = getWeightOfShortestPathBFS(grid, path);\r\n    this.setState({\r\n      timeComplexity: visitedNodesInOrder.length,\r\n      pathLength: path.length,\r\n      pathCost,\r\n    });\r\n    //console.log(path);\r\n    //console.log(grid);\r\n  };\r\n\r\n  visualizeDFS = () => {\r\n    this.clearAlgo(); //for clearing grid for any previous algo if implemented\r\n    const { grid } = this.state;\r\n    const startNode = grid[startNode_Row][startNode_Col];\r\n    const endNode = grid[endNode_Row][endNode_Col];\r\n    const visitedNodesInOrder = dfs(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    const path = getPathDFS(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    this.animateAlgo(visitedNodesInOrder, path);\r\n    const pathCost = getWeightOfPathDFS(grid, path);\r\n    this.setState({\r\n      timeComplexity: visitedNodesInOrder.length,\r\n      pathLength: path.length,\r\n      pathCost,\r\n    });\r\n    //console.log(path);\r\n    //console.log(grid);\r\n  };\r\n\r\n  //clear visitedNodes and shortestPath properties from the grid leaving walls and weights untouched\r\n  clearAlgo = () => {\r\n    const newGrid = this.state.grid;\r\n    for (let row = 0; row < total_rows; row++) {\r\n      for (let column = 0; column < total_columns; column++) {\r\n        newGrid[row][column].distance = Infinity;\r\n        newGrid[row][column].isVisited = false;\r\n        newGrid[row][column].previousNode = null;\r\n        newGrid[row][column].visitedNode = false;\r\n        newGrid[row][column].pathNode = false;\r\n        if (\r\n          !(\r\n            (row === startNode_Row && column === startNode_Col) ||\r\n            (row === endNode_Row && column === endNode_Col) ||\r\n            newGrid[row][column].isWall === true\r\n          )\r\n        ) {\r\n          if (newGrid[row][column].weight > 0) {\r\n            document.getElementById(`node-${row}-${column}`).className =\r\n              \"node weight-present\";\r\n          } else {\r\n            document.getElementById(`node-${row}-${column}`).className = \"node\";\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this.setState({\r\n      grid: newGrid,\r\n      timeComplexity: 0,\r\n      pathLength: 0,\r\n      pathCost: 0,\r\n    });\r\n  };\r\n\r\n  //clear whole grid\r\n  undoAlgoAndWalls = () => {\r\n    const newGrid = this.state.grid;\r\n    for (let row = 0; row < total_rows; row++) {\r\n      for (let column = 0; column < total_columns; column++) {\r\n        newGrid[row][column].distance = Infinity;\r\n        newGrid[row][column].isVisited = false;\r\n        newGrid[row][column].previousNode = null;\r\n        newGrid[row][column].isWall = false;\r\n        newGrid[row][column].weight = 0;\r\n        newGrid[row][column].visitedNode = false;\r\n        newGrid[row][column].pathNode = false;\r\n        if (\r\n          !(\r\n            (row === startNode_Row && column === startNode_Col) ||\r\n            (row === endNode_Row && column === endNode_Col)\r\n          )\r\n        ) {\r\n          document.getElementById(`node-${row}-${column}`).className = \"node\";\r\n        }\r\n      }\r\n    }\r\n    this.setState({\r\n      grid: newGrid,\r\n      timeComplexity: 0,\r\n      pathLength: 0,\r\n      pathCost: 0,\r\n    });\r\n  };\r\n\r\n  handleCheckboxChange = () => {\r\n    //console.log(this.state.addWeights);\r\n    this.setState({ addWeights: !this.state.addWeights });\r\n   // console.log(this.state.addWeights, \"hi\");\r\n  };\r\n\r\n  getDescription=(algo)=>{\r\n    if (algo===\"Dijkstra\"){\r\n      this.setState({description:\"Dijkstra's Algorithm is Weighted and guarantees the Shortest Path!\"});\r\n    }\r\n    else if (algo===\"Astar\"){\r\n      this.setState({description:\"A* Search (AI based Algorithm) is Weighted and guarantees the Shortest Path!\"});\r\n    }\r\n    else if (algo===\"BFS\"){\r\n      this.setState({description:\"Breath-first Search is Unweighted and guarantees the Shortest Path!\"});\r\n    }\r\n    else if (algo===\"DFS\"){\r\n      this.setState({description:\"Depth-first Search is Unweighted and does not guarantee the Shortest path!\"});\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { grid } = this.state;\r\n    //  console.log(grid);\r\n    return (\r\n      // <div className=\"container-fluid\">\r\n      <div>\r\n        <Navbar\r\n          addWeights={this.state.addWeights}\r\n          handleDijkstra={this.visualizeDijkstra}\r\n          handleAstar={this.visualizeAstar}\r\n          handleBFS={this.visualizeBFS}\r\n          handleDFS={this.visualizeDFS}\r\n          handleClearAlgorithm={this.clearAlgo}\r\n          handleClearGrid={this.undoAlgoAndWalls}\r\n          handleCheckboxChange={this.handleCheckboxChange}\r\n          processActive={this.state.processActive}\r\n          timeComplexity={this.state.timeComplexity}\r\n          pathCost={this.state.pathCost}\r\n          pathLength={this.state.pathLength}\r\n          handleDescription={(algo)=>this.getDescription(algo)}\r\n        ></Navbar>\r\n        <div className=\"labels mt-3\">\r\n          <li className=\"node startNode ml-5\"></li>  Start node\r\n          <li className=\"node endNode ml-5\"></li>  End Node\r\n          <li className=\"node node-visited ml-5\"></li>  Visited node\r\n          <li className=\"node node-shortestPath ml-5\"></li>  Path Node\r\n          <li className=\"node wall-true ml-5\"></li>  Obstacle Node\r\n          <li className=\"node weight-present ml-5\"></li>  Weight Node\r\n          <li className=\"node ml-5\"></li>  Unvisited Node\r\n        </div>\r\n\r\n        <div className=\"description mt-3\">\r\n          {this.state.description}\r\n        </div>\r\n        \r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      row={node.row}\r\n                      column={node.column}\r\n                      isStart={node.isStart}\r\n                      isEnd={node.isEnd}\r\n                      distance={node.distance}\r\n                      isVisited={node.isVisited}\r\n                      previousNode={node.previousNode}\r\n                      isWall={node.isWall}\r\n                      weight={node.weight}\r\n                      visitedNode={node.visitedNode}\r\n                      pathNode={node.pathNode}\r\n                      // isMousePressed={isMousePressed}\r\n                      onMouseDown={(row, column) =>\r\n                        this.handleMouseDown(row, column)\r\n                      }\r\n                      onMouseEnter={(row, column) =>\r\n                        this.handleMouseEnter(row, column)\r\n                      }\r\n                      onMouseUp={(row, column) =>\r\n                        this.handleMouseUp(row, column)\r\n                      }\r\n                      onMouseLeave={(row, column) =>\r\n                        this.handleMouseLeave(row,column)\r\n                      }\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n        {/* <Footer/> */}\r\n        <div className=\"footer mt-2\">\r\n          <p>Created by Kush Gupta <span role=\"img\" aria-label=\"owl\">🦉 Hosted on <a href=\"https://github.com/kushgupta-official/Graph-algo-visualizer\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a></span> \r\n          </p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default GraphAlgoVisualizer;\r\n","import React from 'react';\r\n\r\n\r\nclass Canvas extends React.Component {\r\n\r\n    state = {\r\n        coord: []\r\n    }\r\n\r\n    newCanvas() {\r\n\r\n        let newcoord = [];\r\n        const ctx = this.canvas.getContext('2d');\r\n        this.setState({ coord: newcoord }, function () {\r\n            this.props.draw(this.canvas, ctx, this.state.coord);\r\n            //console.log(this.state.coord);\r\n        });\r\n    }\r\n    prims() {\r\n\r\n        let visited = [];\r\n        let unvisited = [];\r\n        let unvisited1 = [];\r\n        for (let i in this.state.coord) {\r\n            unvisited.push(this.state.coord[i]);\r\n            unvisited1.push(this.state.coord[i]);\r\n        }\r\n        let length = unvisited.length;\r\n        let first = unvisited[0];\r\n\r\n        visited.push(first);\r\n        unvisited.splice(0, 1);\r\n\r\n        while (length > 1) {\r\n\r\n\r\n            let minEdge = Infinity;\r\n            let parent = null;\r\n            let currentVertex = null;\r\n            for (let i in visited) {\r\n\r\n                for (let j in unvisited) {\r\n                    let weight = this.calWeight(visited[i][0], visited[i][1], unvisited[j][0], unvisited[j][1]);\r\n                    if (minEdge > weight) {\r\n                        minEdge = weight;\r\n                        currentVertex = j;\r\n                        parent = i;\r\n                    }\r\n                }\r\n\r\n            }\r\n            console.log(visited, unvisited);\r\n            this.props.drawPrims(parent, currentVertex, visited, unvisited, this.canvas, this.canvas.getContext('2d'));\r\n            visited.push(unvisited[currentVertex]);\r\n            unvisited.splice(currentVertex, 1);\r\n            length = length - 1;\r\n        }\r\n    }\r\n    calWeight(x1, y1, x2, y2) {\r\n        let x = Math.pow(x1 - x2, 2);\r\n        let y = Math.pow(y1 - y2, 2);\r\n        return Math.sqrt(x + y);\r\n    }\r\n\r\n\r\n    componentDidMount() {\r\n        const ctx = this.canvas.getContext('2d');\r\n        this.props.outline(this.canvas, ctx);\r\n    }\r\n\r\n    render() {\r\n        let width = window.innerWidth - 45;\r\n        let height = window.innerHeight * 0.6;\r\n        \r\n        return (\r\n            <div id=\"head\">\r\n\r\n                <div className=\" pt-2 pb-2 bg-dark text-light container-float\">\r\n                    <div className=\"navbar-brand ml-4 \">\r\n                        Minimum Spanning Tree\r\n                    </div>\r\n                </div>\r\n                    \r\n\r\n                    \r\n                    <div className=\"mt-2 mt-2 d-flex justify-content-center\">\r\n                        You can start drawing the MST by clicking on canvas.\r\n                    </div>\r\n                    <div className=\"mt-2 d-flex justify-content-center\">\r\n                        <b>Left-Click</b>&nbsp;to Add |&nbsp;<b>Right-Click</b>&nbsp;to Remove.\r\n                    </div>\r\n                    <div className=\"mt-2 d-flex justify-content-center\">\r\n                        Generated by&nbsp;<b>Prim's Algorithm</b>&nbsp;using&nbsp;<b>Euclidean Distances</b>&nbsp;as weights of graph\r\n                    </div>\r\n\r\n                    <button className=\"btn btn-outline-dark float-right mr-4 pt-2\" onClick={() => { this.newCanvas() }}>\r\n                        <b>Clear Canvas</b>\r\n                    </button>\r\n                <canvas\r\n                    className=\"mr-4 ml-4 mt-2 bg-light\"\r\n                    onClick={(e) => {\r\n                        const ctx = this.canvas.getContext('2d');\r\n                        let coord = [];\r\n                        let xypair = [];\r\n                        coord.push(e.clientX);\r\n                        coord.push(e.clientY);\r\n\r\n                        xypair.push(coord);\r\n\r\n                        if (this.state.coord.length === 0) {\r\n                            this.setState({ coord: xypair }, function () {\r\n                                //->prims (prims will draw edges)\r\n                                this.props.draw(this.canvas, ctx, this.state.coord);\r\n                            });\r\n                        }\r\n                        else {\r\n                            let newCoord = this.state.coord;\r\n                            newCoord.push(xypair[0]);\r\n                            this.setState({ coord: newCoord }, function () {\r\n                                this.props.draw(this.canvas, ctx, this.state.coord);\r\n                                this.prims();\r\n                                //console.log(this.state.coord);\r\n                            });\r\n\r\n                        }\r\n\r\n                    }}\r\n                    onContextMenu={(e) => {\r\n\r\n                        e.preventDefault();\r\n                        const ctx = this.canvas.getContext('2d');\r\n                        let coordX = e.clientX;\r\n                        let coordY = e.clientY;\r\n                        let coord = this.state.coord;\r\n\r\n                        for (let i in this.state.coord) {\r\n                            let isInside = Math.sqrt(Math.pow(coord[i][0] - coordX, 2) + Math.pow(coord[i][1] - coordY, 2)) < 8;\r\n                            if (isInside) {\r\n                                coord.splice(i, 1);\r\n                                break;\r\n                            }\r\n                        }\r\n                        this.setState({ coord: coord }, function () {\r\n                            this.props.draw(this.canvas, ctx, this.state.coord);\r\n                            this.prims();\r\n                        });\r\n\r\n                    }}\r\n\r\n                    ref={node => (this.canvas = node)}\r\n                    width={width}\r\n                    height={height}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Canvas;","import React from 'react';\r\n\r\nimport Canvas from \"./canvas\";\r\nimport 'bootstrap/dist/css/bootstrap.css';\r\n  class MinimumSpanningTree extends React.Component {\r\n\r\n    constructor(props) {\r\n      super(props);\r\n      this.ChildElement = React.createRef();\r\n    }\r\n\r\n    render() {\r\n      \r\n      return (\r\n          <>\r\n          <Canvas\r\n            width={1405}\r\n            height={500}\r\n            outline={(canvas, ctx) => {\r\n              ctx.strokeRect( 0, 0, canvas.width, canvas.height);\r\n            }}\r\n            draw={(canvas, ctx, coord) => {\r\n              let rect = canvas.getBoundingClientRect();\r\n              ctx.clearRect( 0, 0, canvas.width, canvas.height);\r\n              ctx.strokeRect( 0, 0, canvas.width, canvas.height);\r\n              for (let i in coord) {\r\n                ctx.fillStyle = \"#1e2433\";\r\n                ctx.beginPath();\r\n                ctx.arc(coord[i][0]-rect.left , coord[i][1]-rect.top , 10, 0, 2 * Math.PI);\r\n                ctx.fill();\r\n              }\r\n            }\r\n            }\r\n\r\n            drawPrims={(source, destination, visited, unvisited, canvas, ctx) => {\r\n              let rect = canvas.getBoundingClientRect();\r\n              ctx.strokeStyle = \"#1e1e33\";\r\n              ctx.beginPath();\r\n              ctx.moveTo(visited[source][0] - rect.left, visited[source][1]-rect.top );\r\n              ctx.lineTo(unvisited[destination][0]-rect.left , unvisited[destination][1] -rect.top );\r\n              ctx.stroke();\r\n            }\r\n            }\r\n          />\r\n          </>\r\n      );\r\n    }\r\n  }\r\n\r\nexport default MinimumSpanningTree;\r\n","import React from 'react'\r\n// import { NavLink } from 'react-router-dom'\r\nimport Nav from 'react-bootstrap/Nav'\r\nimport {Link} from 'react-router-dom'\r\n\r\nconst Header = () => {\r\n    // const {location}=props;\r\n    return (\r\n      <Nav justify variant=\"pills\" defaultActiveKey=\"/gav\" className=\"bg-dark border border-light border-1\" sticky=\"top\">\r\n      <Nav.Item>\r\n        <Link to=\"/gav\">\r\n            <Nav.Link href=\"/gav\">\r\n                Path Finding Visualizer\r\n            </Nav.Link>\r\n        </Link>\r\n      </Nav.Item>\r\n      <Nav.Item>\r\n        <Link to=\"/mst\">\r\n            <Nav.Link href=\"/mst\" eventKey=\"link-1\">\r\n            Minimum Spanning Tree\r\n            </Nav.Link>\r\n        </Link>\r\n      </Nav.Item>\r\n      {/* <Nav.Item>\r\n        <Link to=\"/gav\">\r\n            <Nav.Link href=\"/gav\" eventKey=\"link-2\">\r\n                Topological Sorting\r\n            </Nav.Link>\r\n        </Link>\r\n      </Nav.Item> */}\r\n    </Nav>\r\n    )\r\n}\r\n\r\nexport default Header\r\n","import React, { Component } from \"react\";\nimport GraphAlgoVisualizer from \"./graphAlgoVisualizer/graphAlgoVisualizer\";\nimport MinimumSpanningTree from \"./minimumSpanningTree/minimumSpanningTree\";\nimport {\n  BrowserRouter as Router,\n  Routes as Switch, \n  Route, \n} from 'react-router-dom';\nimport Header from \"./Header\";\n// import \"./App.css\";\n\nclass App extends Component {\n  state = {};\n  render() {\n    return (\n      //<div className=\"App-header\">\n      <Router>\n           {/* <div className=\"App\"> */}\n           <Header />\n            <Switch>\n            <Route exact path=\"/\" element={<GraphAlgoVisualizer />} />\n              <Route exact path=\"/Graph-Algo-Visualizer\" element={<GraphAlgoVisualizer />} />\n              <Route exact path='/gav' element={<GraphAlgoVisualizer />} />\n              <Route exact path=\"/mst\" element={<MinimumSpanningTree />} />\n              {/* <Route exact path='/contact' component={Contact}></Route> */}\n            </Switch>\n          {/* </div> */}\n       </Router>\n      // <div>\n      //   <GraphAlgoVisualizer />\n      // </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport ReactGA from \"react-ga\";\nReactGA.initialize(\"UA-179559461-1\");\nReactGA.pageview(window.location.pathname + window.location.search);\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}