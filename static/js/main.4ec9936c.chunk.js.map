{"version":3,"sources":["graphAlgoVisualizer/node/node.jsx","graphAlgoVisualizer/navbar.jsx","algorithms/dijkstra.js","algorithms/aStar.js","algorithms/bfs.js","algorithms/dfs.js","graphAlgoVisualizer/graphAlgoVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","state","getClassName","str","props","isStart","isEnd","isWall","weight","this","row","column","onMouseDown","onMouseUp","onMouseEnter","className","id","Component","classNavbar","currentAlgo","forDijkstra","setState","forAstar","forBFS","forDFS","visualize","handleDijkstra","handleAstar","handleBFS","handleDFS","handleClearAlgorithm","handleClearGrid","Navbar","bg","variant","expand","Brand","Toggle","aria-controls","Collapse","Nav","NavDropdown","title","Item","onClick","Button","dijkstra","grid","startNode","endNode","visitedNodeInOrder","distance","unvisitedNodes","nodes","columns","push","getAllNodes","console","log","length","sortNodesByDistance","nearestNode","shift","isVisited","Infinity","updateUnvisitedNeighbours","sort","nodeA","nodeB","node","unvisitedNeighbours","getUnvisitedNeighbours","ite","previousNode","getShortestPathDijkstra","shortestPath","previous","reverse","getWeightOfShortestPathDijkstra","weightOfPath","aStar","visitedNodesInOrder","Math","abs","toReturn","rows","sortNodesByValueF","nextNode","currentNode","targetNode","distanceBetweenCurrentAndTarget","g_currentNode","g_ite","h_ite","getShortestPathAstar","getWeightOfShortestPathAstar","bfs","queue","currNode","pushNeighboursOfCurrentNode","neighboursOfCurrentNode","getNeighboursOfCurrentNode","getPathBFS","path","getWeightOfShortestPathBFS","dfs","stack","pop","pushNeighboursOfNode","neighboursOfNode","getNeighboursOfNode","getPathDFS","getWeightOfPathDFS","startNode_Row","startNode_Col","endNode_Row","endNode_Col","Checkbox","type","GraphAlgoVisualizer","isMousePressed","timeComplexity","pathCost","pathLength","isMovingStart","isMovingEnd","addWeights","processActive","getNewGridWithWallToggled","newGrid","slice","newNode","getNewGridWithWeights","changeInValue","handleMouseDown","handleMouseEnter","handleMouseUp","animateAlgo","i","j","setTimeout","document","getElementById","visualizeDijkstra","clearAlgo","shortestPathCost","visualizeAstar","visualizeBFS","visualizeDFS","undoAlgoAndWalls","handleCheckboxChange","currentRow","checked","onChange","map","rowIdx","key","nodeIdx","App","Boolean","window","location","hostname","match","ReactGA","initialize","pageview","pathname","search","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.4ec9936c.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport \"./node.css\";\r\n\r\nclass Node extends Component {\r\n  state = {};\r\n  getClassName = () => {\r\n    let str = \"node\";\r\n    if (this.props.isStart === true) {\r\n      str = str + \" startNode\";\r\n    } else if (this.props.isEnd === true) {\r\n      str = str + \" endNode\";\r\n    } else if (this.props.isWall === true) {\r\n      str = str + \" wall-true\";\r\n    } else if (this.props.weight > 0) {\r\n      str = str + \" weight-present\";\r\n    }\r\n    return str;\r\n  };\r\n\r\n  render() {\r\n    const {\r\n      row,\r\n      column,\r\n      // isStart,\r\n      // isEnd,\r\n      // distance,\r\n      // isVisited,\r\n      // previousNode,\r\n      // isWall,\r\n      // weight,\r\n      onMouseDown,\r\n      onMouseUp,\r\n      onMouseEnter,\r\n    } = this.props;\r\n    //console.log(  this.props);\r\n    return (\r\n      <div\r\n        className={this.getClassName()}\r\n        id={`node-${row}-${column}`}\r\n        onMouseDown={() => onMouseDown(row, column)}\r\n        onMouseEnter={() => onMouseEnter(row, column)}\r\n        onMouseUp={() => onMouseUp(row, column)}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Node;\r\n","import React, { Component } from \"react\";\r\nimport Navbar from \"react-bootstrap/Navbar\";\r\nimport Nav from \"react-bootstrap/Nav\";\r\nimport NavDropdown from \"react-bootstrap/NavDropdown\";\r\nimport Button from \"react-bootstrap/Button\";\r\n\r\nclass classNavbar extends Component {\r\n  state = {\r\n    currentAlgo: \"null\",\r\n  };\r\n  forDijkstra = () => {\r\n    this.setState({ currentAlgo: \"Dijkstra\" });\r\n  };\r\n  forAstar = () => {\r\n    this.setState({ currentAlgo: \"Astar\" });\r\n  };\r\n  forBFS = () => {\r\n    this.setState({ currentAlgo: \"BFS\" });\r\n  };\r\n  forDFS = () => {\r\n    this.setState({ currentAlgo: \"DFS\" });\r\n  };\r\n  visualize = () => {\r\n    if (this.state.currentAlgo === \"Dijkstra\") {\r\n      this.props.handleDijkstra();\r\n    } else if (this.state.currentAlgo === \"Astar\") {\r\n      this.props.handleAstar();\r\n    } else if (this.state.currentAlgo === \"BFS\") {\r\n      this.props.handleBFS();\r\n    } else if (this.state.currentAlgo === \"DFS\") {\r\n      this.props.handleDFS();\r\n    }\r\n  };\r\n  render() {\r\n    const { handleClearAlgorithm, handleClearGrid } = this.props;\r\n    return (\r\n      <Navbar bg=\"dark\" variant=\"dark\" expand=\"lg\">\r\n        <Navbar.Brand className=\"mr-5\">Graph Algo Visualizer</Navbar.Brand>\r\n        <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\r\n        <Navbar.Collapse id=\"basic-navbar-nav\">\r\n          <Nav className=\"mr-auto\">\r\n            {/* <Nav.Link href=\"#home\">Home</Nav.Link>\r\n            <Nav.Link href=\"#link\">Link</Nav.Link> */}\r\n            <NavDropdown title=\"Algorithms\" id=\"basic-nav-dropdown\">\r\n              <NavDropdown.Item onClick={this.forDijkstra}>\r\n                Dijkstra\r\n              </NavDropdown.Item>\r\n              <NavDropdown.Item onClick={this.forAstar}>\r\n                A* Search\r\n              </NavDropdown.Item>\r\n              <NavDropdown.Item onClick={this.forBFS}>\r\n                Breadth First Search\r\n              </NavDropdown.Item>\r\n              <NavDropdown.Item onClick={this.forDFS}>\r\n                Depth First Search\r\n              </NavDropdown.Item>\r\n              {/* <NavDropdown.Divider />\r\n              <NavDropdown.Item\">\r\n                Separated link\r\n              </NavDropdown.Item> */}\r\n            </NavDropdown>\r\n            <Button variant=\"success\" className=\"mx-5\" onClick={this.visualize}>\r\n              Visualize!\r\n            </Button>\r\n            <Button\r\n              variant=\"info\"\r\n              className=\"mx-5\"\r\n              onClick={handleClearAlgorithm}\r\n            >\r\n              Clear Algorithm\r\n            </Button>\r\n            <Button variant=\"info\" className=\"mx-5\" onClick={handleClearGrid}>\r\n              Clear Grid\r\n            </Button>\r\n          </Nav>\r\n        </Navbar.Collapse>\r\n      </Navbar>\r\n    );\r\n  }\r\n}\r\n\r\nexport default classNavbar;\r\n","export function dijkstra(grid, startNode, endNode) {\r\n  const visitedNodeInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  console.log(unvisitedNodes);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const nearestNode = unvisitedNodes.shift();\r\n    nearestNode.isVisited = true;\r\n    if (nearestNode.distance === Infinity) {\r\n      return visitedNodeInOrder;\r\n    }\r\n    if (nearestNode.isWall === true) {\r\n      continue;\r\n    }\r\n    // nearestNode.isVisited = true;\r\n    visitedNodeInOrder.push(nearestNode);\r\n    if (nearestNode === endNode) {\r\n      return visitedNodeInOrder;\r\n    }\r\n    updateUnvisitedNeighbours(nearestNode, grid);\r\n    // console.log(visitedNodeInOrder);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbours(node, grid) {\r\n  const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\r\n  for (let ite of unvisitedNeighbours) {\r\n    if (ite.distance > node.distance + ite.weight) {\r\n      ite.distance = node.distance + ite.weight + 1;\r\n      ite.previousNode = node;\r\n    }\r\n  }\r\n  return unvisitedNeighbours;\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  const unvisitedNeighbours = [];\r\n  const { row, column } = node;\r\n  if (row - 1 >= 0 && grid[row - 1][column].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row - 1][column]);\r\n\r\n  if (row + 1 < grid.length && grid[row + 1][column].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row + 1][column]);\r\n\r\n  if (column - 1 >= 0 && grid[row][column - 1].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row][column - 1]);\r\n\r\n  if (column + 1 < grid[0].length && grid[row][column + 1].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row][column + 1]);\r\n\r\n  return unvisitedNeighbours;\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  let nodes = [];\r\n  for (let row of grid) {\r\n    for (let columns of row) {\r\n      nodes.push(columns);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function getShortestPathDijkstra(grid, startNode, endNode) {\r\n  const shortestPath = [];\r\n  let previous = endNode.previousNode;\r\n  if (previous === null) {\r\n    return shortestPath;\r\n  }\r\n  while (previous !== startNode) {\r\n    shortestPath.push(previous);\r\n    previous = previous.previousNode;\r\n  }\r\n  shortestPath.reverse();\r\n  return shortestPath;\r\n}\r\n\r\nexport function getWeightOfShortestPathDijkstra(grid, shortestPath) {\r\n  let weightOfPath = 0;\r\n  for (let ite of shortestPath) {\r\n    if (ite.weight === 0) {\r\n      weightOfPath = weightOfPath + 1;\r\n    } else {\r\n      weightOfPath = weightOfPath + ite.weight + 1;\r\n    }\r\n  }\r\n  return weightOfPath;\r\n}\r\n","//here distance is f in a* algo\r\n//f=g+h\r\nexport function aStar(grid, startNode, endNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance =\r\n    Math.abs(startNode.row - endNode.row) +\r\n    Math.abs(startNode.column - endNode.column);\r\n  // startNode.distance=0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByValueF(unvisitedNodes);\r\n    const nextNode = unvisitedNodes.shift();\r\n    if (nextNode.distance === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (nextNode.isWall) {\r\n      continue;\r\n    }\r\n    nextNode.isVisited = true;\r\n    visitedNodesInOrder.push(nextNode);\r\n    if (nextNode === endNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    updateUnvisitedNeighbours(nextNode, endNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByValueF(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const toReturn = [];\r\n  for (let rows of grid) {\r\n    for (let columns of rows) {\r\n      toReturn.push(columns);\r\n    }\r\n  }\r\n  return toReturn;\r\n}\r\n\r\nfunction updateUnvisitedNeighbours(currentNode, targetNode, grid) {\r\n  const unvisitedNeighbours = getUnvisitedNeighbours(currentNode, grid);\r\n  const distanceBetweenCurrentAndTarget =\r\n    Math.abs(currentNode.row - targetNode.row) +\r\n    Math.abs(currentNode.column - targetNode.column);\r\n  const g_currentNode = currentNode.distance - distanceBetweenCurrentAndTarget;\r\n  for (let ite of unvisitedNeighbours) {\r\n    let g_ite = g_currentNode + ite.weight + 1;\r\n    let h_ite =\r\n      Math.abs(ite.row - targetNode.row) +\r\n      Math.abs(ite.column - targetNode.column);\r\n    if (ite.distance > g_ite + h_ite) {\r\n      ite.distance = g_ite + h_ite;\r\n      ite.previousNode = currentNode;\r\n    }\r\n  }\r\n  return unvisitedNeighbours;\r\n}\r\n\r\n// function updateUnvisitedNeighbours(currentNode, targetNode, grid) {\r\n//   const unvisitedNeighbours = getUnvisitedNeighbours(currentNode, grid);\r\n//   const distanceBetweenCurrentAndTarget =\r\n//     currentNode.distance -\r\n//     (Math.abs(currentNode.row - targetNode.row) +\r\n//       Math.abs(currentNode.column - targetNode.column));\r\n//   // const distanceBetweenCurrentAndTarget = currentNode.distance;\r\n//   for (let ite of unvisitedNeighbours) {\r\n//     if (\r\n//       ite.distance >\r\n//       distanceBetweenCurrentAndTarget +\r\n//         ite.weight +\r\n//         Math.abs(ite.row - targetNode.row) +\r\n//         Math.abs(ite.column - targetNode.column)\r\n//     ) {\r\n//       ite.distance =\r\n//         distanceBetweenCurrentAndTarget +\r\n//         ite.weight +\r\n//         Math.abs(ite.row - targetNode.row) +\r\n//         Math.abs(ite.column - targetNode.column);\r\n//       ite.previousNode = currentNode;\r\n//     }\r\n//   }\r\n//   return unvisitedNeighbours;\r\n// }\r\n\r\nfunction getUnvisitedNeighbours(currentNode, grid) {\r\n  const unvisitedNeighbours = [];\r\n  const { row, column } = currentNode;\r\n  if (row - 1 >= 0 && grid[row - 1][column].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row - 1][column]);\r\n\r\n  if (row + 1 < grid.length && grid[row + 1][column].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row + 1][column]);\r\n\r\n  if (column - 1 >= 0 && grid[row][column - 1].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row][column - 1]);\r\n\r\n  if (column + 1 < grid[0].length && grid[row][column + 1].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row][column + 1]);\r\n\r\n  return unvisitedNeighbours;\r\n}\r\n\r\nexport function getShortestPathAstar(grid, startNode, endNode) {\r\n  const shortestPath = [];\r\n  let previous = endNode.previousNode;\r\n  if (previous === null) {\r\n    return shortestPath;\r\n  }\r\n  while (previous !== startNode) {\r\n    shortestPath.push(previous);\r\n    previous = previous.previousNode;\r\n  }\r\n  shortestPath.reverse();\r\n  return shortestPath;\r\n}\r\n\r\nexport function getWeightOfShortestPathAstar(grid, shortestPath) {\r\n  let weightOfPath = 0;\r\n  for (let ite of shortestPath) {\r\n    if (ite.weight === 0) {\r\n      weightOfPath = weightOfPath + 1;\r\n    } else {\r\n      weightOfPath = weightOfPath + ite.weight + 1;\r\n    }\r\n  }\r\n  return weightOfPath;\r\n}\r\n","export function bfs(grid, startNode, endNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.isVisited = true;\r\n  //    const unvisitedNodes=extractAllNodes(grid);\r\n  const queue = [];\r\n  queue.push(startNode);\r\n  while (!!queue.length) {\r\n    const currNode = queue.shift();\r\n    if (currNode === endNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (currNode.isWall) {\r\n      continue;\r\n    }\r\n    visitedNodesInOrder.push(currNode);\r\n    pushNeighboursOfCurrentNode(grid, queue, currNode);\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction pushNeighboursOfCurrentNode(grid, queue, currNode) {\r\n  const neighboursOfCurrentNode = getNeighboursOfCurrentNode(grid, currNode);\r\n  for (let node of neighboursOfCurrentNode) {\r\n    node.isVisited = true;\r\n    node.previousNode = currNode;\r\n    queue.push(node);\r\n  }\r\n}\r\n\r\nfunction getNeighboursOfCurrentNode(grid, currNode) {\r\n  const toReturn = [];\r\n  const row = currNode.row;\r\n  const column = currNode.column;\r\n\r\n  if (row - 1 >= 0 && !grid[row - 1][column].isVisited)\r\n    toReturn.push(grid[row - 1][column]);\r\n\r\n  if (column - 1 >= 0 && !grid[row][column - 1].isVisited)\r\n    toReturn.push(grid[row][column - 1]);\r\n\r\n  if (row + 1 < grid.length && !grid[row + 1][column].isVisited)\r\n    toReturn.push(grid[row + 1][column]);\r\n\r\n  if (column + 1 < grid[0].length && !grid[row][column + 1].isVisited)\r\n    toReturn.push(grid[row][column + 1]);\r\n\r\n  return toReturn;\r\n}\r\n\r\n// function extractAllNodes(grid){\r\n//     const toReturn=[];\r\n//     for (let row of grid){\r\n//         for (let column of row){\r\n//             toReturn.push(column);\r\n//         }\r\n//     }\r\n//     return toReturn;\r\n// }\r\n\r\nexport function getPathBFS(grid, startNode, endNode) {\r\n  const path = [];\r\n  let previous = endNode.previousNode;\r\n  if (previous === null) {\r\n    return path;\r\n  }\r\n  while (previous !== startNode) {\r\n    path.push(previous);\r\n    previous = previous.previousNode;\r\n  }\r\n  path.reverse();\r\n  return path;\r\n}\r\n\r\nexport function getWeightOfShortestPathBFS(grid, path) {\r\n  let weightOfPath = 0;\r\n  for (let ite of path) {\r\n    if (ite.weight === 0) {\r\n      weightOfPath = weightOfPath + 1;\r\n    } else {\r\n      weightOfPath = weightOfPath + ite.weight + 1;\r\n    }\r\n  }\r\n  return weightOfPath;\r\n}\r\n","export function dfs(grid, startNode, endNode) {\r\n  const visitedNodesInOrder = [];\r\n  const stack = [];\r\n  startNode.isVisited = true;\r\n  stack.push(startNode);\r\n  while (!!stack.length) {\r\n    const nextNode = stack.pop();\r\n    if (nextNode.isWall === true) {\r\n      continue;\r\n    }\r\n    visitedNodesInOrder.push(nextNode);\r\n    if (nextNode === endNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    pushNeighboursOfNode(grid, stack, nextNode);\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction pushNeighboursOfNode(grid, stack, node) {\r\n  const neighboursOfNode = getNeighboursOfNode(grid, node);\r\n  for (let ite of neighboursOfNode) {\r\n    ite.previousNode = node;\r\n    ite.isVisited = true;\r\n    stack.push(ite);\r\n  }\r\n}\r\n\r\nfunction getNeighboursOfNode(grid, node) {\r\n  const unvisitedNeighbours = [];\r\n  const row = node.row;\r\n  const column = node.column;\r\n\r\n  if (row - 1 >= 0 && grid[row - 1][column].isVisited === false) {\r\n    unvisitedNeighbours.push(grid[row - 1][column]);\r\n  }\r\n  if (column - 1 >= 0 && grid[row][column - 1].isVisited === false) {\r\n    unvisitedNeighbours.push(grid[row][column - 1]);\r\n  }\r\n  if (row + 1 < grid.length && grid[row + 1][column].isVisited === false) {\r\n    unvisitedNeighbours.push(grid[row + 1][column]);\r\n  }\r\n  if (\r\n    column + 1 < grid[0].length &&\r\n    grid[row][column + 1].isVisited === false\r\n  ) {\r\n    unvisitedNeighbours.push(grid[row][column + 1]);\r\n  }\r\n\r\n  return unvisitedNeighbours;\r\n}\r\n\r\nexport function getPathDFS(grid, startNode, endNode) {\r\n  const path = [];\r\n  let previous = endNode.previousNode;\r\n  if (previous === null) {\r\n    return path;\r\n  }\r\n  while (previous !== startNode) {\r\n    path.push(previous);\r\n    previous = previous.previousNode;\r\n  }\r\n  path.reverse();\r\n  return path;\r\n}\r\n\r\nexport function getWeightOfPathDFS(grid, path) {\r\n  let weightOfPath = 0;\r\n  for (let ite of path) {\r\n    if (ite.weight === 0) {\r\n      weightOfPath = weightOfPath + 1;\r\n    } else {\r\n      weightOfPath = weightOfPath + ite.weight + 1;\r\n    }\r\n  }\r\n  return weightOfPath;\r\n}\r\n","// value along path, dfs\r\nimport React, { Component } from \"react\";\r\nimport Node from \"./node/node.jsx\";\r\nimport Navbar from \"./navbar\";\r\nimport \"./graphAlgoVisualizer.css\";\r\nimport {\r\n  dijkstra,\r\n  getShortestPathDijkstra,\r\n  getWeightOfShortestPathDijkstra,\r\n} from \"../algorithms/dijkstra.js\";\r\nimport {\r\n  aStar,\r\n  getShortestPathAstar,\r\n  getWeightOfShortestPathAstar,\r\n} from \"../algorithms/aStar.js\";\r\nimport {\r\n  bfs,\r\n  getPathBFS,\r\n  getWeightOfShortestPathBFS,\r\n} from \"../algorithms/bfs.js\";\r\nimport { dfs, getPathDFS, getWeightOfPathDFS } from \"../algorithms/dfs\";\r\n\r\nconst total_rows = 20;\r\nconst total_columns = 40;\r\nvar startNode_Row = 5;\r\nvar startNode_Col = 10;\r\nvar endNode_Row = 10;\r\nvar endNode_Col = 37;\r\nconst FixedWeight = 10;\r\n\r\nconst Checkbox = (props) => <input type=\"checkbox\" {...props} />;\r\nclass GraphAlgoVisualizer extends Component {\r\n  state = {\r\n    grid: [],\r\n    isMousePressed: false,\r\n    timeComplexity: 0,\r\n    pathCost: 0,\r\n    pathLength: 0,\r\n    isMovingStart: false,\r\n    isMovingEnd: false,\r\n    addWeights: false,\r\n    processActive: false,\r\n  };\r\n\r\n  componentDidMount() {\r\n    const grid = [];\r\n    for (let row = 0; row < total_rows; row++) {\r\n      const currentRow = [];\r\n      for (let column = 0; column < total_columns; column++) {\r\n        const currentNode = {\r\n          row,\r\n          column,\r\n          isStart: row === startNode_Row && column === startNode_Col,\r\n          isEnd: row === endNode_Row && column === endNode_Col,\r\n          distance: Infinity,\r\n          weight: 0,\r\n          isVisited: false,\r\n          previousNode: null,\r\n          isWall: false,\r\n        };\r\n        currentRow.push(currentNode);\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    this.setState({ grid });\r\n  }\r\n\r\n  getNewGridWithWallToggled = (row, column) => {\r\n    const newGrid = this.state.grid.slice();\r\n    const node = newGrid[row][column];\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n      weight: 0,\r\n    };\r\n    newGrid[row][column] = newNode;\r\n    return newGrid;\r\n  };\r\n\r\n  getNewGridWithWeights = (row, column) => {\r\n    const newGrid = this.state.grid.slice();\r\n    const node = newGrid[row][column];\r\n    let changeInValue = 0;\r\n    if (node.weight === 0) {\r\n      changeInValue = FixedWeight;\r\n    } else {\r\n      changeInValue = -FixedWeight;\r\n    }\r\n    const newNode = {\r\n      ...node,\r\n      isWall: false,\r\n      weight: node.weight + changeInValue,\r\n    };\r\n    newGrid[row][column] = newNode;\r\n    return newGrid;\r\n  };\r\n\r\n  handleMouseDown = (row, column) => {\r\n    if (\r\n      !(\r\n        (row === startNode_Row && column === startNode_Col) ||\r\n        (row === endNode_Row && column === endNode_Col)\r\n      )\r\n    ) {\r\n      console.log(row, column, \"mouse down\");\r\n      let newGrid;\r\n      if (!this.state.addWeights) {\r\n        newGrid = this.getNewGridWithWallToggled(row, column);\r\n      } else {\r\n        newGrid = this.getNewGridWithWeights(row, column);\r\n      }\r\n      this.setState({ grid: newGrid, isMousePressed: true });\r\n    }\r\n    // if user wants to change positon of start or end node\r\n    else {\r\n      console.log(row, column, \"mouse down starting or ending\");\r\n      this.setState({ isMousePressed: true });\r\n      if (row === startNode_Row && column === startNode_Col) {\r\n        const newGrid = this.state.grid.slice();\r\n        const node = newGrid[row][column];\r\n        const newNode = {\r\n          ...node,\r\n          isStart: false,\r\n        };\r\n        newGrid[row][column] = newNode;\r\n        this.setState({ grid: newGrid, isMovingStart: true });\r\n      } else if (row === endNode_Row && column === endNode_Col) {\r\n        const newGrid = this.state.grid.slice();\r\n        const node = newGrid[row][column];\r\n        const newNode = {\r\n          ...node,\r\n          isEnd: false,\r\n        };\r\n        newGrid[row][column] = newNode;\r\n        this.setState({ grid: newGrid, isMovingEnd: true });\r\n      }\r\n    }\r\n  };\r\n\r\n  handleMouseEnter = (row, column) => {\r\n    if (!this.state.isMousePressed) return;\r\n    if (this.state.isMovingStart || this.state.isMovingEnd) return;\r\n    if (\r\n      !(\r\n        (row === startNode_Row && column === startNode_Col) ||\r\n        (row === endNode_Row && column === endNode_Col)\r\n      )\r\n    ) {\r\n      console.log(row, column, \"mouse enter\");\r\n      let newGrid;\r\n      if (!this.state.addWeights) {\r\n        newGrid = this.getNewGridWithWallToggled(row, column);\r\n      } else {\r\n        newGrid = this.getNewGridWithWeights(row, column);\r\n      }\r\n      this.setState({ grid: newGrid });\r\n    } else {\r\n      console.log(\"mouse entered starting or ending\");\r\n    }\r\n  };\r\n\r\n  handleMouseUp = (row, column) => {\r\n    console.log(\"mouse up\");\r\n    this.setState({ isMousePressed: false });\r\n\r\n    //if moving start or end\r\n    if (this.state.isMovingStart === true) {\r\n      const newGrid = this.state.grid.slice();\r\n      const node = newGrid[row][column];\r\n      const newNode = {\r\n        ...node,\r\n        isWall: false,\r\n        isStart: true,\r\n      };\r\n      newGrid[row][column] = newNode;\r\n      this.setState({ grid: newGrid, isMovingStart: false });\r\n      startNode_Row = row;\r\n      startNode_Col = column;\r\n    } else if (this.state.isMovingEnd === true) {\r\n      const newGrid = this.state.grid.slice();\r\n      const node = newGrid[row][column];\r\n      const newNode = {\r\n        ...node,\r\n        isWall: false,\r\n        isEnd: true,\r\n      };\r\n      newGrid[row][column] = newNode;\r\n      this.setState({ grid: newGrid, isMovingEnd: false });\r\n      endNode_Row = row;\r\n      endNode_Col = column;\r\n    }\r\n  };\r\n\r\n  animateAlgo = (visitedNodesInOrder, shortestPath) => {\r\n    // document.getElementById(\"function\").disabled = true;\r\n    for (let i = 1; i < visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        for (let j = 0; j < shortestPath.length; j++) {\r\n          setTimeout(() => {\r\n            setTimeout(() => {\r\n              const node = shortestPath[j];\r\n              if (\r\n                document.getElementById(`node-${node.row}-${node.column}`)\r\n                  .className === \"node weight-present-visited\"\r\n              ) {\r\n                document.getElementById(\r\n                  `node-${node.row}-${node.column}`\r\n                ).className = \"node weight-present-path\";\r\n              } else {\r\n                document.getElementById(\r\n                  `node-${node.row}-${node.column}`\r\n                ).className = \"node node-shortestPath\";\r\n              }\r\n            }, 50 * j);\r\n          }, 25 * i);\r\n        }\r\n        //Finally the solution to bug\r\n        // setTimeout(() => {\r\n        //   setTimeout(() => {\r\n        //     console.log(\"ho jayega\");\r\n        //     document.getElementById(\"function\").disabled = false;\r\n        //   }, 50 * shortestPath.length);\r\n        // }, 25 * visitedNodesInOrder.length);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        if (\r\n          document.getElementById(`node-${node.row}-${node.column}`)\r\n            .className === \"node weight-present\"\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.column}`).className =\r\n            \"node weight-present-visited\";\r\n        } else {\r\n          document.getElementById(`node-${node.row}-${node.column}`).className =\r\n            \"node node-visited\";\r\n        }\r\n      }, 25 * i);\r\n    }\r\n  };\r\n\r\n  visualizeDijkstra = () => {\r\n    // const toBeDisabled = document.getElementById(\"button\");\r\n    // toBeDisabled.disabled = true;\r\n    this.clearAlgo(); //for clearing grid for any previous algo if implemented\r\n    const { grid } = this.state;\r\n    const startNode = grid[startNode_Row][startNode_Col];\r\n    const endNode = grid[endNode_Row][endNode_Col];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    const shortestPath = getShortestPathDijkstra(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    const shortestPathCost = getWeightOfShortestPathDijkstra(\r\n      grid,\r\n      shortestPath\r\n    );\r\n    this.animateAlgo(visitedNodesInOrder, shortestPath);\r\n    this.setState({\r\n      timeComplexity: visitedNodesInOrder.length,\r\n      pathLength: shortestPath.length,\r\n      pathCost: shortestPathCost,\r\n    });\r\n    // toBeDisabled.disabled = false;\r\n    // console.log(shortestPath);\r\n    // console.log(grid);\r\n  };\r\n\r\n  visualizeAstar = () => {\r\n    this.clearAlgo(); //for clearing grid for any previous algo if implemented\r\n    const { grid } = this.state;\r\n    const startNode = grid[startNode_Row][startNode_Col];\r\n    const endNode = grid[endNode_Row][endNode_Col];\r\n    const visitedNodesInOrder = aStar(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    const shortestPath = getShortestPathAstar(grid, startNode, endNode);\r\n    console.log(visitedNodesInOrder);\r\n    const shortestPathCost = getWeightOfShortestPathAstar(grid, shortestPath);\r\n    this.animateAlgo(visitedNodesInOrder, shortestPath);\r\n    this.setState({\r\n      timeComplexity: visitedNodesInOrder.length,\r\n      pathLength: shortestPath.length,\r\n      pathCost: shortestPathCost,\r\n    });\r\n    // console.log(shortestPath);\r\n    // console.log(grid);\r\n  };\r\n\r\n  visualizeBFS = () => {\r\n    this.clearAlgo(); //for clearing grid for any previous algo if implemented\r\n    const { grid } = this.state;\r\n    const startNode = grid[startNode_Row][startNode_Col];\r\n    const endNode = grid[endNode_Row][endNode_Col];\r\n    const visitedNodesInOrder = bfs(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    const path = getPathBFS(grid, startNode, endNode);\r\n    console.log(visitedNodesInOrder);\r\n    this.animateAlgo(visitedNodesInOrder, path);\r\n    const pathCost = getWeightOfShortestPathBFS(grid, path);\r\n    this.setState({\r\n      timeComplexity: visitedNodesInOrder.length,\r\n      pathLength: path.length,\r\n      pathCost,\r\n    });\r\n    console.log(path);\r\n    console.log(grid);\r\n  };\r\n\r\n  visualizeDFS = () => {\r\n    this.clearAlgo(); //for clearing grid for any previous algo if implemented\r\n    const { grid } = this.state;\r\n    const startNode = grid[startNode_Row][startNode_Col];\r\n    const endNode = grid[endNode_Row][endNode_Col];\r\n    const visitedNodesInOrder = dfs(grid, startNode, endNode);\r\n    console.log(visitedNodesInOrder);\r\n    const path = getPathDFS(grid, startNode, endNode);\r\n    console.log(visitedNodesInOrder);\r\n    this.animateAlgo(visitedNodesInOrder, path);\r\n    const pathCost = getWeightOfPathDFS(grid, path);\r\n    this.setState({\r\n      timeComplexity: visitedNodesInOrder.length,\r\n      pathLength: path.length,\r\n      pathCost,\r\n    });\r\n    console.log(path);\r\n    console.log(grid);\r\n  };\r\n\r\n  //clear visitedNodes and shortestPath properties from the grid leaving walls and weights untouched\r\n  clearAlgo = () => {\r\n    const newGrid = this.state.grid;\r\n    for (let row = 0; row < total_rows; row++) {\r\n      for (let column = 0; column < total_columns; column++) {\r\n        newGrid[row][column].distance = Infinity;\r\n        newGrid[row][column].isVisited = false;\r\n        newGrid[row][column].previousNode = null;\r\n        if (\r\n          !(\r\n            (row === startNode_Row && column === startNode_Col) ||\r\n            (row === endNode_Row && column === endNode_Col) ||\r\n            newGrid[row][column].isWall === true\r\n          )\r\n        ) {\r\n          if (newGrid[row][column].weight > 0) {\r\n            document.getElementById(`node-${row}-${column}`).className =\r\n              \"node weight-present\";\r\n          } else {\r\n            document.getElementById(`node-${row}-${column}`).className = \"node\";\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this.setState({\r\n      grid: newGrid,\r\n      timeComplexity: 0,\r\n      pathLength: 0,\r\n      pathCost: 0,\r\n    });\r\n  };\r\n\r\n  undoAlgoAndWalls = () => {\r\n    const newGrid = this.state.grid;\r\n    for (let row = 0; row < total_rows; row++) {\r\n      for (let column = 0; column < total_columns; column++) {\r\n        newGrid[row][column].distance = Infinity;\r\n        newGrid[row][column].isVisited = false;\r\n        newGrid[row][column].previousNode = null;\r\n        newGrid[row][column].isWall = false;\r\n        newGrid[row][column].weight = 0;\r\n        if (\r\n          !(\r\n            (row === startNode_Row && column === startNode_Col) ||\r\n            (row === endNode_Row && column === endNode_Col)\r\n          )\r\n        ) {\r\n          document.getElementById(`node-${row}-${column}`).className = \"node\";\r\n        }\r\n      }\r\n    }\r\n    this.setState({\r\n      grid: newGrid,\r\n      timeComplexity: 0,\r\n      pathLength: 0,\r\n      pathCost: 0,\r\n    });\r\n  };\r\n\r\n  handleCheckboxChange = () => {\r\n    console.log(this.state.addWeights);\r\n    this.setState({ addWeights: !this.state.addWeights });\r\n    console.log(this.state.addWeights, \"hi\");\r\n  };\r\n\r\n  render() {\r\n    const { grid } = this.state;\r\n    //  console.log(grid);\r\n    return (\r\n      // <div className=\"container-fluid\">\r\n      <div>\r\n        <Navbar\r\n          handleDijkstra={this.visualizeDijkstra}\r\n          handleAstar={this.visualizeAstar}\r\n          handleBFS={this.visualizeBFS}\r\n          handleDFS={this.visualizeDFS}\r\n          handleClearAlgorithm={this.clearAlgo}\r\n          handleClearGrid={this.undoAlgoAndWalls}\r\n        ></Navbar>\r\n        {/* <button\r\n          className=\"btn btn-primary btn-lg\"\r\n          id=\"dijkstra-btn\"\r\n          onClick={this.visualizeDijkstra}\r\n        >\r\n          Visualize Dijkstra Algorithm\r\n        </button>\r\n        <button\r\n          className=\"btn btn-primary btn-lg\"\r\n          id=\"astar-btn\"\r\n          onClick={this.visualizeAstar}\r\n        >\r\n          Visualize A* Algorithm\r\n        </button>\r\n        <button\r\n          className=\"btn btn-primary btn-lg\"\r\n          id=\"dfs-btn\"\r\n          onClick={this.visualizeDFS}\r\n        >\r\n          Depth First Search\r\n        </button>\r\n        <button\r\n          className=\"btn btn-primary btn-lg\"\r\n          id=\"bfs-btn\"\r\n          onClick={this.visualizeBFS}\r\n        >\r\n          Breadth First Search\r\n        </button>\r\n        <button\r\n          className=\"btn btn-primary btn-lg\"\r\n          id=\"function\"\r\n          onClick={this.undoAlgoAndWalls}\r\n        >\r\n          Undo Algo and walls\r\n        </button>\r\n        <button\r\n          className=\"btn btn-primary btn-lg\"\r\n          id=\"function\"\r\n          onClick={this.clearAlgo}\r\n        >\r\n          Clear Algo\r\n        </button> */}\r\n        <label>\r\n          <Checkbox\r\n            checked={this.state.addWeights}\r\n            onChange={this.handleCheckboxChange}\r\n          />\r\n          <span>Switch to Weights</span>\r\n        </label>\r\n        <div>\r\n          <span className=\"time\">\r\n            Time Complexity = {this.state.timeComplexity}\r\n          </span>\r\n          <span className=\"pathLength\">\r\n            Path Length = {this.state.pathLength}\r\n          </span>\r\n          <span className=\"pathCost\">Path Cost = {this.state.pathCost}</span>\r\n        </div>\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {\r\n                    row,\r\n                    column,\r\n                    isStart,\r\n                    isEnd,\r\n                    distance,\r\n                    isVisited,\r\n                    previousNode,\r\n                    isWall,\r\n                    weight,\r\n                    isMousePressed,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      row={row}\r\n                      column={column}\r\n                      isStart={isStart}\r\n                      isEnd={isEnd}\r\n                      distance={distance}\r\n                      isVisited={isVisited}\r\n                      previousNode={previousNode}\r\n                      isWall={isWall}\r\n                      weight={weight}\r\n                      isMousePressed={isMousePressed}\r\n                      onMouseDown={(row, column) =>\r\n                        this.handleMouseDown(row, column)\r\n                      }\r\n                      onMouseEnter={(row, column) =>\r\n                        this.handleMouseEnter(row, column)\r\n                      }\r\n                      onMouseUp={(row, column) =>\r\n                        this.handleMouseUp(row, column)\r\n                      }\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default GraphAlgoVisualizer;\r\n","import React, { Component } from \"react\";\nimport GraphAlgoVisualizer from \"./graphAlgoVisualizer/graphAlgoVisualizer\";\n//import \"./App.css\";\n\nclass App extends Component {\n  state = {};\n  render() {\n    return (\n      //<div className=\"App-header\">\n      <div>\n        <GraphAlgoVisualizer />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport ReactGA from \"react-ga\";\nReactGA.initialize(\"UA-179559461-1\");\nReactGA.pageview(window.location.pathname + window.location.search);\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}