{"version":3,"sources":["graphAlgoVisualizer/node/node.jsx","algorithms/dijkstra.js","algorithms/aStar.js","graphAlgoVisualizer/graphAlgoVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","state","getClassName","str","props","isStart","isEnd","isWall","this","row","column","onMouseDown","distance","isVisited","previousNode","onMouseUp","onMouseEnter","className","id","Component","dijkstra","grid","startNode","endNode","visitedNodeInOrder","unvisitedNodes","nodes","columns","push","getAllNodes","console","log","length","sortNodesByDistance","nearestNode","shift","Infinity","updateUnvisitedNeighbours","sort","nodeA","nodeB","node","unvisitedNeighbours","getUnvisitedNeighbours","ite","getShortestPathDijkstra","shortestPath","previous","reverse","aStar","visitedNodesInOrder","Math","abs","toReturn","rows","sortNodesByValueF","nextNode","currentNode","targetNode","getShortestPathAstar","startNode_Row","startNode_Col","endNode_Row","endNode_Col","GraphAlgoVisualizer","isMousePressed","timeComplexity","isMovingStart","isMovingEnd","getNewGridWithWallToggled","newGrid","slice","newNode","handleMouseDown","setState","handleMouseEnter","handleMouseUp","animateAlgo","i","j","setTimeout","document","getElementById","visualizeDijkstra","clearAlgo","visualizeAstar","undoAlgoAndWalls","currentRow","onClick","map","rowIdx","key","nodeIdx","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"0RA4CeA,G,kNAxCbC,MAAQ,G,EACRC,aAAe,WACb,IAAIC,EAAM,OAQV,OAP2B,IAAvB,EAAKC,MAAMC,QACbF,GAAY,cACkB,IAArB,EAAKC,MAAME,MACpBH,GAAY,YACmB,IAAtB,EAAKC,MAAMG,SACpBJ,GAAY,cAEPA,G,uDAGC,IAAD,EAaHK,KAAKJ,MAXPK,EAFK,EAELA,IACAC,EAHK,EAGLA,OAOAC,GAVK,EAILN,QAJK,EAKLC,MALK,EAMLM,SANK,EAOLC,UAPK,EAQLC,aARK,EASLP,OATK,EAULI,aACAI,EAXK,EAWLA,UACAC,EAZK,EAYLA,aAGF,OACE,yBACEC,UAAWT,KAAKN,eAChBgB,GAAE,eAAUT,EAAV,YAAiBC,GACnBC,YAAa,kBAAMA,EAAYF,EAAKC,IACpCM,aAAc,kBAAMA,EAAaP,EAAKC,IACtCK,UAAW,kBAAMA,EAAUN,EAAKC,U,GAnCrBS,c,eCGZ,SAASC,EAASC,EAAMC,EAAWC,GACxC,IAAMC,EAAqB,GAC3BF,EAAUV,SAAW,EACrB,IAAMa,EAoDR,SAAqBJ,GACnB,IADyB,EACrBK,EAAQ,GADa,cAETL,GAFS,IAEzB,2BAAsB,CAAC,IAAD,EAAbZ,EAAa,sBACAA,GADA,IACpB,2BAAyB,CAAC,IAAjBkB,EAAgB,QACvBD,EAAME,KAAKD,IAFO,gCAFG,8BAOzB,OAAOD,EA3DgBG,CAAYR,GAEnC,IADAS,QAAQC,IAAIN,GACHA,EAAeO,QAAQ,CAC9BC,EAAoBR,GACpB,IAAMS,EAAcT,EAAeU,QACnC,GAAID,EAAYtB,WAAawB,IAC3B,OAAOZ,EAET,IAA2B,IAAvBU,EAAY3B,OAAhB,CAKA,GAFA2B,EAAYrB,WAAY,EACxBW,EAAmBI,KAAKM,GACpBA,IAAgBX,EAClB,OAAOC,EAETa,EAA0BH,EAAab,KAK3C,SAASY,EAAoBR,GAC3BA,EAAea,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAM3B,SAAW4B,EAAM5B,YAG/D,SAASyB,EAA0BI,EAAMpB,GACvC,IAD6C,EACvCqB,EAQR,SAAgCD,EAAMpB,GACpC,IAAMqB,EAAsB,GACpBjC,EAAgBgC,EAAhBhC,IAAKC,EAAW+B,EAAX/B,OACTD,EAAM,GAAK,IAAyC,IAApCY,EAAKZ,EAAM,GAAGC,GAAQG,WACxC6B,EAAoBd,KAAKP,EAAKZ,EAAM,GAAGC,IAErCD,EAAM,EAAIY,EAAKW,SAA8C,IAApCX,EAAKZ,EAAM,GAAGC,GAAQG,WACjD6B,EAAoBd,KAAKP,EAAKZ,EAAM,GAAGC,IAErCA,EAAS,GAAK,IAAyC,IAApCW,EAAKZ,GAAKC,EAAS,GAAGG,WAC3C6B,EAAoBd,KAAKP,EAAKZ,GAAKC,EAAS,IAE1CA,EAAS,EAAIW,EAAK,GAAGW,SAA8C,IAApCX,EAAKZ,GAAKC,EAAS,GAAGG,WACvD6B,EAAoBd,KAAKP,EAAKZ,GAAKC,EAAS,IAE9C,OAAOgC,EAvBqBC,CAAuBF,EAAMpB,GADZ,cAE3BqB,GAF2B,IAE7C,2BAAuC,CAAC,IAA7BE,EAA4B,QACrCA,EAAIhC,SAAW6B,EAAK7B,SAAW,EAC/BgC,EAAI9B,aAAe2B,GAJwB,8BAM7C,OAAOC,EA+BF,SAASG,EAAwBxB,EAAMC,EAAWC,GACvD,IAAMuB,EAAe,GACjBC,EAAWxB,EAAQT,aACvB,GAAiB,OAAbiC,EACF,OAAOD,EAET,KAAOC,IAAazB,GAClBwB,EAAalB,KAAKmB,GAClBA,EAAWA,EAASjC,aAGtB,OADAgC,EAAaE,UACNF,EChFF,SAASG,EAAM5B,EAAMC,EAAWC,GACrC,IAAM2B,EAAsB,GAC5B5B,EAAUV,SACRuC,KAAKC,IAAI9B,EAAUb,IAAMc,EAAQd,KACjC0C,KAAKC,IAAI9B,EAAUZ,OAASa,EAAQb,QAEtC,IADA,IAAMe,EAuBR,SAAqBJ,GACnB,IADyB,EACnBgC,EAAW,GADQ,cAERhC,GAFQ,IAEzB,2BAAuB,CAAC,IAAD,EAAdiC,EAAc,sBACDA,GADC,IACrB,2BAA0B,CAAC,IAAlB3B,EAAiB,QACxB0B,EAASzB,KAAKD,IAFK,gCAFE,8BAOzB,OAAO0B,EA9BgBxB,CAAYR,GAC1BI,EAAeO,QAAQ,CAC9BuB,EAAkB9B,GAClB,IAAM+B,EAAW/B,EAAeU,QAChC,GAAIqB,EAAS5C,WAAawB,IACxB,OAAOc,EAET,IAAIM,EAASjD,OAAb,CAKA,GAFAiD,EAAS3C,WAAY,EACrBqC,EAAoBtB,KAAK4B,GACrBA,IAAajC,EACf,OAAO2B,EAETb,EAA0BmB,EAAUjC,EAASF,KAIjD,SAASkC,EAAkB9B,GACzBA,EAAea,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAM3B,SAAW4B,EAAM5B,YAa/D,SAASyB,EAA0BoB,EAAaC,EAAYrC,GAC1D,IADgE,EAC1DqB,EAcR,SAAgCe,EAAapC,GAC3C,IAAMqB,EAAsB,GACpBjC,EAAgBgD,EAAhBhD,IAAKC,EAAW+C,EAAX/C,OACTD,EAAM,GAAK,IAAyC,IAApCY,EAAKZ,EAAM,GAAGC,GAAQG,WACxC6B,EAAoBd,KAAKP,EAAKZ,EAAM,GAAGC,IAErCD,EAAM,EAAIY,EAAKW,SAA8C,IAApCX,EAAKZ,EAAM,GAAGC,GAAQG,WACjD6B,EAAoBd,KAAKP,EAAKZ,EAAM,GAAGC,IAErCA,EAAS,GAAK,IAAyC,IAApCW,EAAKZ,GAAKC,EAAS,GAAGG,WAC3C6B,EAAoBd,KAAKP,EAAKZ,GAAKC,EAAS,IAE1CA,EAAS,EAAIW,EAAK,GAAGW,SAA8C,IAApCX,EAAKZ,GAAKC,EAAS,GAAGG,WACvD6B,EAAoBd,KAAKP,EAAKZ,GAAKC,EAAS,IAE9C,OAAOgC,EA7BqBC,CAAuBc,EAAapC,GADA,cAEhDqB,GAFgD,IAEhE,2BAAqC,CAAC,IAA7BE,EAA4B,QACnCA,EAAIhC,SACF6C,EAAY7C,UACXuC,KAAKC,IAAIK,EAAYhD,IAAMiD,EAAWjD,KACrC0C,KAAKC,IAAIK,EAAY/C,OAASgD,EAAWhD,SAC3C,EACAyC,KAAKC,IAAIR,EAAInC,IAAMiD,EAAWjD,KAC9B0C,KAAKC,IAAIR,EAAIlC,OAASgD,EAAWhD,QACnCkC,EAAI9B,aAAe2C,GAV2C,8BAYhE,OAAOf,EAqBF,SAASiB,EAAqBtC,EAAMC,EAAWC,GACpD,IAAMuB,EAAe,GACjBC,EAAWxB,EAAQT,aACvB,GAAiB,OAAbiC,EACF,OAAOD,EAET,KAAOC,IAAazB,GAClBwB,EAAalB,KAAKmB,GAClBA,EAAWA,EAASjC,aAGtB,OADAgC,EAAaE,UACNF,EC3ET,IAEIc,EAAgB,EAChBC,EAAgB,GAChBC,EAAc,GACdC,EAAc,GAiTHC,E,4MA7Sb/D,MAAQ,CACNoB,KAAM,GACN4C,gBAAgB,EAChBC,eAAgB,EAChBC,eAAe,EACfC,aAAa,G,EAyBfC,0BAA4B,SAAC5D,EAAKC,GAChC,IAAM4D,EAAU,EAAKrE,MAAMoB,KAAKkD,QAC1B9B,EAAO6B,EAAQ7D,GAAKC,GACpB8D,EAAO,2BACR/B,GADQ,IAEXlC,QAASkC,EAAKlC,SAGhB,OADA+D,EAAQ7D,GAAKC,GAAU8D,EAChBF,G,EAGTG,gBAAkB,SAAChE,EAAKC,GACtB,GAEKD,IAAQmD,GAAiBlD,IAAWmD,GACpCpD,IAAQqD,GAAepD,IAAWqD,GAWrC,GAFAjC,QAAQC,IAAItB,EAAKC,EAAQ,iCACzB,EAAKgE,SAAS,CAAET,gBAAgB,IAC5BxD,IAAQmD,GAAiBlD,IAAWmD,EAAe,CACrD,IAAMS,EAAU,EAAKrE,MAAMoB,KAAKkD,QAC1B9B,EAAO6B,EAAQ7D,GAAKC,GACpB8D,EAAO,2BACR/B,GADQ,IAEXpC,SAAS,IAEXiE,EAAQ7D,GAAKC,GAAU8D,EACvB,EAAKE,SAAS,CAAErD,KAAMiD,EAASH,eAAe,SACzC,GAAI1D,IAAQqD,GAAepD,IAAWqD,EAAa,CACxD,IAAMO,EAAU,EAAKrE,MAAMoB,KAAKkD,QAC1B9B,EAAO6B,EAAQ7D,GAAKC,GACpB8D,EAAO,2BACR/B,GADQ,IAEXnC,OAAO,IAETgE,EAAQ7D,GAAKC,GAAU8D,EACvB,EAAKE,SAAS,CAAErD,KAAMiD,EAASF,aAAa,SA1B9C,CACAtC,QAAQC,IAAItB,EAAKC,EAAQ,cACzB,IAAM4D,EAAU,EAAKD,0BAA0B5D,EAAKC,GACpD,EAAKgE,SAAS,CAAErD,KAAMiD,EAASL,gBAAgB,M,EA4BnDU,iBAAmB,SAAClE,EAAKC,GACvB,GAAK,EAAKT,MAAMgE,iBACZ,EAAKhE,MAAMkE,gBAAiB,EAAKlE,MAAMmE,YAC3C,GAEK3D,IAAQmD,GAAiBlD,IAAWmD,GACpCpD,IAAQqD,GAAepD,IAAWqD,EAOrCjC,QAAQC,IAAI,wCALZ,CACAD,QAAQC,IAAItB,EAAKC,EAAQ,eACzB,IAAM4D,EAAU,EAAKD,0BAA0B5D,EAAKC,GACpD,EAAKgE,SAAS,CAAErD,KAAMiD,M,EAM1BM,cAAgB,SAACnE,EAAKC,GAKpB,GAJAoB,QAAQC,IAAI,YACZ,EAAK2C,SAAS,CAAET,gBAAgB,KAGC,IAA7B,EAAKhE,MAAMkE,cAAwB,CACrC,IAAMG,EAAU,EAAKrE,MAAMoB,KAAKkD,QAC1B9B,EAAO6B,EAAQ7D,GAAKC,GACpB8D,EAAO,2BACR/B,GADQ,IAEXlC,QAAQ,EACRF,SAAS,IAEXiE,EAAQ7D,GAAKC,GAAU8D,EACvB,EAAKE,SAAS,CAAErD,KAAMiD,EAASH,eAAe,IAC9CP,EAAgBnD,EAChBoD,EAAgBnD,OACX,IAA+B,IAA3B,EAAKT,MAAMmE,YAAsB,CAC1C,IAAME,EAAU,EAAKrE,MAAMoB,KAAKkD,QAC1B9B,EAAO6B,EAAQ7D,GAAKC,GACpB8D,EAAO,2BACR/B,GADQ,IAEXlC,QAAQ,EACRD,OAAO,IAETgE,EAAQ7D,GAAKC,GAAU8D,EACvB,EAAKE,SAAS,CAAErD,KAAMiD,EAASF,aAAa,IAC5CN,EAAcrD,EACdsD,EAAcrD,I,EAIlBmE,YAAc,SAAC3B,EAAqBJ,GAClC,IADoD,IAAD,WAC1CgC,GACP,GAAIA,IAAM5B,EAAoBlB,OAAS,EAAG,CACxC,IADyC,IAAD,WAC/B+C,GACPC,YAAW,WACTA,YAAW,WACT,IAAMvC,EAAOK,EAAaiC,GAC1BE,SAASC,eAAT,eACUzC,EAAKhC,IADf,YACsBgC,EAAK/B,SACzBO,UAAY,2BACb,GAAK8D,KACP,GAAKD,IARDC,EAAI,EAAGA,EAAIjC,EAAad,OAAQ+C,IAAzC,EAASA,GAST,MAAM,CAAN,UAEFC,YAAW,WACT,IAAMvC,EAAOS,EAAoB4B,GACjCG,SAASC,eAAT,eAAgCzC,EAAKhC,IAArC,YAA4CgC,EAAK/B,SAAUO,UACzD,sBACD,GAAK6D,IAjBDA,EAAI,EAAGA,EAAI5B,EAAoBlB,OAAQ8C,IAAK,CAAC,IAAD,IAA5CA,GAA4C,oC,EAqBvDK,kBAAoB,WAClB,EAAKC,YADmB,IAEhB/D,EAAS,EAAKpB,MAAdoB,KACFC,EAAYD,EAAKuC,GAAeC,GAChCtC,EAAUF,EAAKyC,GAAaC,GAC5Bb,EAAsB9B,EAASC,EAAMC,EAAWC,GAEhDuB,EAAeD,EAAwBxB,EAAMC,EAAWC,GAE9D,EAAKsD,YAAY3B,EAAqBJ,GACtC,EAAK4B,SAAS,CAAER,eAAgBhB,EAAoBlB,U,EAKtDqD,eAAiB,WACf,EAAKD,YADgB,IAEb/D,EAAS,EAAKpB,MAAdoB,KACFC,EAAYD,EAAKuC,GAAeC,GAChCtC,EAAUF,EAAKyC,GAAaC,GAC5Bb,EAAsBD,EAAM5B,EAAMC,EAAWC,GAE7CuB,EAAea,EAAqBtC,EAAMC,EAAWC,GAC3DO,QAAQC,IAAImB,GACZ,EAAK2B,YAAY3B,EAAqBJ,GACtC,EAAK4B,SAAS,CAAER,eAAgBhB,EAAoBlB,U,EAKtDoD,UAAY,WAEV,IADA,IAAMd,EAAU,EAAKrE,MAAMoB,KAClBZ,EAAM,EAAGA,EA9LH,GA8LqBA,IAClC,IAAK,IAAIC,EAAS,EAAGA,EA9LL,GA8L6BA,IAC3C4D,EAAQ7D,GAAKC,GAAQE,SAAWwB,IAChCkC,EAAQ7D,GAAKC,GAAQG,WAAY,EACjCyD,EAAQ7D,GAAKC,GAAQI,aAAe,KAG/BL,IAAQmD,GAAiBlD,IAAWmD,GACpCpD,IAAQqD,GAAepD,IAAWqD,IACH,IAAhCO,EAAQ7D,GAAKC,GAAQH,SAGvBuB,QAAQC,IAAI,MACZkD,SAASC,eAAT,eAAgCzE,EAAhC,YAAuCC,IAAUO,UAAY,QAInE,EAAKyD,SAAS,CAAErD,KAAMiD,EAASJ,eAAgB,K,EAGjDoB,iBAAmB,WAEjB,IADA,IAAMhB,EAAU,EAAKrE,MAAMoB,KAClBZ,EAAM,EAAGA,EApNH,GAoNqBA,IAClC,IAAK,IAAIC,EAAS,EAAGA,EApNL,GAoN6BA,IAC3C4D,EAAQ7D,GAAKC,GAAQE,SAAWwB,IAChCkC,EAAQ7D,GAAKC,GAAQG,WAAY,EACjCyD,EAAQ7D,GAAKC,GAAQI,aAAe,KACpCwD,EAAQ7D,GAAKC,GAAQH,QAAS,EAGzBE,IAAQmD,GAAiBlD,IAAWmD,GACpCpD,IAAQqD,GAAepD,IAAWqD,IAGrCjC,QAAQC,IAAI,MACZkD,SAASC,eAAT,eAAgCzE,EAAhC,YAAuCC,IAAUO,UAAY,QAInE,EAAKyD,SAAS,CAAErD,KAAMiD,EAASJ,eAAgB,K,kEAlN/C,IADA,IAAM7C,EAAO,GACJZ,EAAM,EAAGA,EAnBH,GAmBqBA,IAAO,CAEzC,IADA,IAAM8E,EAAa,GACV7E,EAAS,EAAGA,EApBL,GAoB6BA,IAAU,CACrD,IAAM+C,EAAc,CAClBhD,MACAC,SACAL,QAASI,IAAQmD,GAAiBlD,IAAWmD,EAC7CvD,MAAOG,IAAQqD,GAAepD,IAAWqD,EACzCnD,SAAUwB,IACVvB,WAAW,EACXC,aAAc,KACdP,QAAQ,GAEVgF,EAAW3D,KAAK6B,GAElBpC,EAAKO,KAAK2D,GAEZ/E,KAAKkE,SAAS,CAAErD,W,+BAoMR,IAAD,OACCA,EAASb,KAAKP,MAAdoB,KAER,OACE,yBAAKJ,UAAU,mBACb,4BACEA,UAAU,yBACVuE,QAAShF,KAAK2E,mBAFhB,gCAMA,4BACElE,UAAU,yBACVuE,QAAShF,KAAK6E,gBAFhB,0BAMA,4BACEpE,UAAU,yBACVuE,QAAShF,KAAK8E,kBAFhB,uBAMA,4BAAQrE,UAAU,yBAAyBuE,QAAShF,KAAK4E,WAAzD,cAGA,0BAAMnE,UAAU,QAAhB,qBACqBT,KAAKP,MAAMiE,gBAEhC,yBAAKjD,UAAU,QACZI,EAAKoE,KAAI,SAAChF,EAAKiF,GACd,OACE,yBAAKC,IAAKD,GACPjF,EAAIgF,KAAI,SAAChD,EAAMmD,GAAa,IAEzBnF,EASEgC,EATFhC,IACAC,EAQE+B,EARF/B,OACAL,EAOEoC,EAPFpC,QACAC,EAMEmC,EANFnC,MACAM,EAKE6B,EALF7B,SACAC,EAIE4B,EAJF5B,UACAC,EAGE2B,EAHF3B,aACAP,EAEEkC,EAFFlC,OACA0D,EACExB,EADFwB,eAEF,OACE,kBAAC,EAAD,CACE0B,IAAKC,EACLnF,IAAKA,EACLC,OAAQA,EACRL,QAASA,EACTC,MAAOA,EACPM,SAAUA,EACVC,UAAWA,EACXC,aAAcA,EACdP,OAAQA,EACR0D,eAAgBA,EAChBtD,YAAa,SAACF,EAAKC,GAAN,OACX,EAAK+D,gBAAgBhE,EAAKC,IAE5BM,aAAc,SAACP,EAAKC,GAAN,OACZ,EAAKiE,iBAAiBlE,EAAKC,IAE7BK,UAAW,SAACN,EAAKC,GAAN,OACT,EAAKkE,cAAcnE,EAAKC,mB,GAhSdS,aCPnB0E,E,4MANb5F,MAAQ,G,uDAEN,OAAO,kBAAC,EAAD,U,GAHOkB,aCSE2E,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,MCXNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFpB,SAASC,eAAe,SDwHpB,kBAAmBoB,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACL/E,QAAQ+E,MAAMA,EAAMC,a","file":"static/js/main.a175b74b.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport \"./node.css\";\r\n\r\nclass Node extends Component {\r\n  state = {};\r\n  getClassName = () => {\r\n    let str = \"node\";\r\n    if (this.props.isStart === true) {\r\n      str = str + \" startNode\";\r\n    } else if (this.props.isEnd === true) {\r\n      str = str + \" endNode\";\r\n    } else if (this.props.isWall === true) {\r\n      str = str + \" wall-true\";\r\n    }\r\n    return str;\r\n  };\r\n\r\n  render() {\r\n    const {\r\n      row,\r\n      column,\r\n      isStart,\r\n      isEnd,\r\n      distance,\r\n      isVisited,\r\n      previousNode,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseUp,\r\n      onMouseEnter,\r\n    } = this.props;\r\n    //console.log(  this.props);\r\n    return (\r\n      <div\r\n        className={this.getClassName()}\r\n        id={`node-${row}-${column}`}\r\n        onMouseDown={() => onMouseDown(row, column)}\r\n        onMouseEnter={() => onMouseEnter(row, column)}\r\n        onMouseUp={() => onMouseUp(row, column)}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Node;\r\n","/*Problems:\r\n  1. when an operation is going on, no other operation will work\r\n  2. reset button\r\n  3. a star algo\r\n  4. time complexity\r\n*/\r\nexport function dijkstra(grid, startNode, endNode) {\r\n  const visitedNodeInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  console.log(unvisitedNodes);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const nearestNode = unvisitedNodes.shift();\r\n    if (nearestNode.distance === Infinity) {\r\n      return visitedNodeInOrder;\r\n    }\r\n    if (nearestNode.isWall === true) {\r\n      continue;\r\n    }\r\n    nearestNode.isVisited = true;\r\n    visitedNodeInOrder.push(nearestNode);\r\n    if (nearestNode === endNode) {\r\n      return visitedNodeInOrder;\r\n    }\r\n    updateUnvisitedNeighbours(nearestNode, grid);\r\n    // console.log(visitedNodeInOrder);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbours(node, grid) {\r\n  const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\r\n  for (const ite of unvisitedNeighbours) {\r\n    ite.distance = node.distance + 1;\r\n    ite.previousNode = node;\r\n  }\r\n  return unvisitedNeighbours;\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  const unvisitedNeighbours = [];\r\n  const { row, column } = node;\r\n  if (row - 1 >= 0 && grid[row - 1][column].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row - 1][column]);\r\n\r\n  if (row + 1 < grid.length && grid[row + 1][column].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row + 1][column]);\r\n\r\n  if (column - 1 >= 0 && grid[row][column - 1].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row][column - 1]);\r\n\r\n  if (column + 1 < grid[0].length && grid[row][column + 1].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row][column + 1]);\r\n\r\n  return unvisitedNeighbours;\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  let nodes = [];\r\n  for (let row of grid) {\r\n    for (let columns of row) {\r\n      nodes.push(columns);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function getShortestPathDijkstra(grid, startNode, endNode) {\r\n  const shortestPath = [];\r\n  let previous = endNode.previousNode;\r\n  if (previous === null) {\r\n    return shortestPath;\r\n  }\r\n  while (previous !== startNode) {\r\n    shortestPath.push(previous);\r\n    previous = previous.previousNode;\r\n  }\r\n  shortestPath.reverse();\r\n  return shortestPath;\r\n}\r\n","//here distance is f in a* algo\r\n//f=g+h\r\nexport function aStar(grid, startNode, endNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance =\r\n    Math.abs(startNode.row - endNode.row) +\r\n    Math.abs(startNode.column - endNode.column);\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByValueF(unvisitedNodes);\r\n    const nextNode = unvisitedNodes.shift();\r\n    if (nextNode.distance === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (nextNode.isWall) {\r\n      continue;\r\n    }\r\n    nextNode.isVisited = true;\r\n    visitedNodesInOrder.push(nextNode);\r\n    if (nextNode === endNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    updateUnvisitedNeighbours(nextNode, endNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByValueF(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const toReturn = [];\r\n  for (let rows of grid) {\r\n    for (let columns of rows) {\r\n      toReturn.push(columns);\r\n    }\r\n  }\r\n  return toReturn;\r\n}\r\n\r\nfunction updateUnvisitedNeighbours(currentNode, targetNode, grid) {\r\n  const unvisitedNeighbours = getUnvisitedNeighbours(currentNode, grid);\r\n  for (let ite of unvisitedNeighbours) {\r\n    ite.distance =\r\n      currentNode.distance -\r\n      (Math.abs(currentNode.row - targetNode.row) +\r\n        Math.abs(currentNode.column - targetNode.column)) +\r\n      1 +\r\n      Math.abs(ite.row - targetNode.row) +\r\n      Math.abs(ite.column - targetNode.column);\r\n    ite.previousNode = currentNode;\r\n  }\r\n  return unvisitedNeighbours;\r\n}\r\n\r\nfunction getUnvisitedNeighbours(currentNode, grid) {\r\n  const unvisitedNeighbours = [];\r\n  const { row, column } = currentNode;\r\n  if (row - 1 >= 0 && grid[row - 1][column].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row - 1][column]);\r\n\r\n  if (row + 1 < grid.length && grid[row + 1][column].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row + 1][column]);\r\n\r\n  if (column - 1 >= 0 && grid[row][column - 1].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row][column - 1]);\r\n\r\n  if (column + 1 < grid[0].length && grid[row][column + 1].isVisited !== true)\r\n    unvisitedNeighbours.push(grid[row][column + 1]);\r\n\r\n  return unvisitedNeighbours;\r\n}\r\n\r\nexport function getShortestPathAstar(grid, startNode, endNode) {\r\n  const shortestPath = [];\r\n  let previous = endNode.previousNode;\r\n  if (previous === null) {\r\n    return shortestPath;\r\n  }\r\n  while (previous !== startNode) {\r\n    shortestPath.push(previous);\r\n    previous = previous.previousNode;\r\n  }\r\n  shortestPath.reverse();\r\n  return shortestPath;\r\n}\r\n","//time complexity name change\r\n//changing position of start and end\r\n\r\nimport React, { Component } from \"react\";\r\nimport Node from \"./node/node.jsx\";\r\nimport \"./graphAlgoVisualizer.css\";\r\nimport { dijkstra, getShortestPathDijkstra } from \"../algorithms/dijkstra.js\";\r\nimport { aStar, getShortestPathAstar } from \"../algorithms/aStar.js\";\r\n\r\nconst total_rows = 18;\r\nconst total_columns = 50;\r\nvar startNode_Row = 5;\r\nvar startNode_Col = 10;\r\nvar endNode_Row = 10;\r\nvar endNode_Col = 40;\r\nvar time = 0;\r\n\r\nclass GraphAlgoVisualizer extends Component {\r\n  state = {\r\n    grid: [],\r\n    isMousePressed: false,\r\n    timeComplexity: 0,\r\n    isMovingStart: false,\r\n    isMovingEnd: false,\r\n  };\r\n\r\n  componentDidMount() {\r\n    const grid = [];\r\n    for (let row = 0; row < total_rows; row++) {\r\n      const currentRow = [];\r\n      for (let column = 0; column < total_columns; column++) {\r\n        const currentNode = {\r\n          row,\r\n          column,\r\n          isStart: row === startNode_Row && column === startNode_Col,\r\n          isEnd: row === endNode_Row && column === endNode_Col,\r\n          distance: Infinity,\r\n          isVisited: false,\r\n          previousNode: null,\r\n          isWall: false,\r\n        };\r\n        currentRow.push(currentNode);\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    this.setState({ grid });\r\n  }\r\n\r\n  getNewGridWithWallToggled = (row, column) => {\r\n    const newGrid = this.state.grid.slice();\r\n    const node = newGrid[row][column];\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    };\r\n    newGrid[row][column] = newNode;\r\n    return newGrid;\r\n  };\r\n\r\n  handleMouseDown = (row, column) => {\r\n    if (\r\n      !(\r\n        (row === startNode_Row && column === startNode_Col) ||\r\n        (row === endNode_Row && column === endNode_Col)\r\n      )\r\n    ) {\r\n      console.log(row, column, \"mouse down\");\r\n      const newGrid = this.getNewGridWithWallToggled(row, column);\r\n      this.setState({ grid: newGrid, isMousePressed: true });\r\n    }\r\n    // if user wants to change positon of start or end node\r\n    else {\r\n      console.log(row, column, \"mouse down starting or ending\");\r\n      this.setState({ isMousePressed: true });\r\n      if (row === startNode_Row && column === startNode_Col) {\r\n        const newGrid = this.state.grid.slice();\r\n        const node = newGrid[row][column];\r\n        const newNode = {\r\n          ...node,\r\n          isStart: false,\r\n        };\r\n        newGrid[row][column] = newNode;\r\n        this.setState({ grid: newGrid, isMovingStart: true });\r\n      } else if (row === endNode_Row && column === endNode_Col) {\r\n        const newGrid = this.state.grid.slice();\r\n        const node = newGrid[row][column];\r\n        const newNode = {\r\n          ...node,\r\n          isEnd: false,\r\n        };\r\n        newGrid[row][column] = newNode;\r\n        this.setState({ grid: newGrid, isMovingEnd: true });\r\n      }\r\n    }\r\n  };\r\n\r\n  handleMouseEnter = (row, column) => {\r\n    if (!this.state.isMousePressed) return;\r\n    if (this.state.isMovingStart || this.state.isMovingEnd) return;\r\n    if (\r\n      !(\r\n        (row === startNode_Row && column === startNode_Col) ||\r\n        (row === endNode_Row && column === endNode_Col)\r\n      )\r\n    ) {\r\n      console.log(row, column, \"mouse enter\");\r\n      const newGrid = this.getNewGridWithWallToggled(row, column);\r\n      this.setState({ grid: newGrid });\r\n    } else {\r\n      console.log(\"mouse entered starting or ending\");\r\n    }\r\n  };\r\n\r\n  handleMouseUp = (row, column) => {\r\n    console.log(\"mouse up\");\r\n    this.setState({ isMousePressed: false });\r\n\r\n    //if moving start or end\r\n    if (this.state.isMovingStart === true) {\r\n      const newGrid = this.state.grid.slice();\r\n      const node = newGrid[row][column];\r\n      const newNode = {\r\n        ...node,\r\n        isWall: false,\r\n        isStart: true,\r\n      };\r\n      newGrid[row][column] = newNode;\r\n      this.setState({ grid: newGrid, isMovingStart: false });\r\n      startNode_Row = row;\r\n      startNode_Col = column;\r\n    } else if (this.state.isMovingEnd === true) {\r\n      const newGrid = this.state.grid.slice();\r\n      const node = newGrid[row][column];\r\n      const newNode = {\r\n        ...node,\r\n        isWall: false,\r\n        isEnd: true,\r\n      };\r\n      newGrid[row][column] = newNode;\r\n      this.setState({ grid: newGrid, isMovingEnd: false });\r\n      endNode_Row = row;\r\n      endNode_Col = column;\r\n    }\r\n  };\r\n\r\n  animateAlgo = (visitedNodesInOrder, shortestPath) => {\r\n    for (let i = 1; i < visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        for (let j = 0; j < shortestPath.length; j++)\r\n          setTimeout(() => {\r\n            setTimeout(() => {\r\n              const node = shortestPath[j];\r\n              document.getElementById(\r\n                `node-${node.row}-${node.column}`\r\n              ).className = \"node node-shortestPath\";\r\n            }, 50 * j);\r\n          }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.column}`).className =\r\n          \"node node-visited\";\r\n      }, 10 * i);\r\n    }\r\n  };\r\n\r\n  visualizeDijkstra = () => {\r\n    this.clearAlgo(); //for clearing grid for any previous algo if implemented\r\n    const { grid } = this.state;\r\n    const startNode = grid[startNode_Row][startNode_Col];\r\n    const endNode = grid[endNode_Row][endNode_Col];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    const shortestPath = getShortestPathDijkstra(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    this.animateAlgo(visitedNodesInOrder, shortestPath);\r\n    this.setState({ timeComplexity: visitedNodesInOrder.length });\r\n    // console.log(shortestPath);\r\n    // console.log(grid);\r\n  };\r\n\r\n  visualizeAstar = () => {\r\n    this.clearAlgo(); //for clearing grid for any previous algo if implemented\r\n    const { grid } = this.state;\r\n    const startNode = grid[startNode_Row][startNode_Col];\r\n    const endNode = grid[endNode_Row][endNode_Col];\r\n    const visitedNodesInOrder = aStar(grid, startNode, endNode);\r\n    //console.log(visitedNodesInOrder);\r\n    const shortestPath = getShortestPathAstar(grid, startNode, endNode);\r\n    console.log(visitedNodesInOrder);\r\n    this.animateAlgo(visitedNodesInOrder, shortestPath);\r\n    this.setState({ timeComplexity: visitedNodesInOrder.length });\r\n    // console.log(shortestPath);\r\n    // console.log(grid);\r\n  };\r\n\r\n  clearAlgo = () => {\r\n    const newGrid = this.state.grid;\r\n    for (let row = 0; row < total_rows; row++) {\r\n      for (let column = 0; column < total_columns; column++) {\r\n        newGrid[row][column].distance = Infinity;\r\n        newGrid[row][column].isVisited = false;\r\n        newGrid[row][column].previousNode = null;\r\n        if (\r\n          !(\r\n            (row === startNode_Row && column === startNode_Col) ||\r\n            (row === endNode_Row && column === endNode_Col) ||\r\n            newGrid[row][column].isWall === true\r\n          )\r\n        ) {\r\n          console.log(\"hi\");\r\n          document.getElementById(`node-${row}-${column}`).className = \"node\";\r\n        }\r\n      }\r\n    }\r\n    this.setState({ grid: newGrid, timeComplexity: 0 });\r\n  };\r\n\r\n  undoAlgoAndWalls = () => {\r\n    const newGrid = this.state.grid;\r\n    for (let row = 0; row < total_rows; row++) {\r\n      for (let column = 0; column < total_columns; column++) {\r\n        newGrid[row][column].distance = Infinity;\r\n        newGrid[row][column].isVisited = false;\r\n        newGrid[row][column].previousNode = null;\r\n        newGrid[row][column].isWall = false;\r\n        if (\r\n          !(\r\n            (row === startNode_Row && column === startNode_Col) ||\r\n            (row === endNode_Row && column === endNode_Col)\r\n          )\r\n        ) {\r\n          console.log(\"hi\");\r\n          document.getElementById(`node-${row}-${column}`).className = \"node\";\r\n        }\r\n      }\r\n    }\r\n    this.setState({ grid: newGrid, timeComplexity: 0 });\r\n  };\r\n\r\n  render() {\r\n    const { grid } = this.state;\r\n    //  console.log(grid);\r\n    return (\r\n      <div className=\"container-fluid\">\r\n        <button\r\n          className=\"btn btn-primary btn-lg\"\r\n          onClick={this.visualizeDijkstra}\r\n        >\r\n          Visualize Dijkstra Algorithm\r\n        </button>\r\n        <button\r\n          className=\"btn btn-primary btn-lg\"\r\n          onClick={this.visualizeAstar}\r\n        >\r\n          Visualize A* Algorithm\r\n        </button>\r\n        <button\r\n          className=\"btn btn-primary btn-lg\"\r\n          onClick={this.undoAlgoAndWalls}\r\n        >\r\n          Undo Algo and walls\r\n        </button>\r\n        <button className=\"btn btn-primary btn-lg\" onClick={this.clearAlgo}>\r\n          Clear Algo\r\n        </button>\r\n        <span className=\"time\">\r\n          Time Complexity = {this.state.timeComplexity}\r\n        </span>\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {\r\n                    row,\r\n                    column,\r\n                    isStart,\r\n                    isEnd,\r\n                    distance,\r\n                    isVisited,\r\n                    previousNode,\r\n                    isWall,\r\n                    isMousePressed,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      row={row}\r\n                      column={column}\r\n                      isStart={isStart}\r\n                      isEnd={isEnd}\r\n                      distance={distance}\r\n                      isVisited={isVisited}\r\n                      previousNode={previousNode}\r\n                      isWall={isWall}\r\n                      isMousePressed={isMousePressed}\r\n                      onMouseDown={(row, column) =>\r\n                        this.handleMouseDown(row, column)\r\n                      }\r\n                      onMouseEnter={(row, column) =>\r\n                        this.handleMouseEnter(row, column)\r\n                      }\r\n                      onMouseUp={(row, column) =>\r\n                        this.handleMouseUp(row, column)\r\n                      }\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default GraphAlgoVisualizer;\r\n","import React, { Component } from \"react\";\nimport GraphAlgoVisualizer from \"./graphAlgoVisualizer/graphAlgoVisualizer\";\n\nclass App extends Component {\n  state = {};\n  render() {\n    return <GraphAlgoVisualizer />;\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}